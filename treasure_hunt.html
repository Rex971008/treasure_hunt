<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çˆ¶è¦ªç¯€å¤§å†’éšªï¼</title>
    <style>
        :root {
            --wall-color: #2c3e50; --path-color: #ecf0f1; --start-color: #3498db;
            --treasure-color: #f1c40f; --player-size: 28px; --cell-size: 40px;
            --primary-bg: #34495e; --text-color: #ffffff; --button-bg: #2ecc71;
            --button-hover-bg: #27ae60; --danger-bg: #e74c3c; --dark-color: #1a2531;
            --visible-transition: background-color 0.4s ease, opacity 0.4s ease;
        }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; font-family: 'Microsoft JhengHei', 'å¾®è»Ÿæ­£é»‘é«”', sans-serif; background-color: var(--primary-bg); color: var(--text-color); overflow: hidden; -webkit-user-select: none; user-select: none; }
        .screen { display: none; width: 100%; height: 100%; flex-direction: column; justify-content: center; align-items: center; text-align: center; box-sizing: border-box; padding: 20px; animation: fadeIn 0.5s ease-in-out; position: relative; z-index: 1; /* Ensure screens are above general background elements */ }
        .screen.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        h1 { font-size: 3em; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        h2 { font-size: 2em; margin-bottom: 30px; }
        p { font-size: 1.2em; margin-top: 20px; line-height: 1.6; }
        .button { background-color: var(--button-bg); color: white; padding: 15px 30px; border: none; border-radius: 8px; font-size: 1.2em; cursor: pointer; margin: 10px; transition: all 0.3s ease; box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
        .button.danger { background-color: var(--danger-bg); }
        .button.danger:hover { background-color: #c0392b; }
        .button:hover:not(:disabled) { background-color: var(--button-hover-bg); transform: translateY(-2px); }
        .button:active:not(:disabled) { transform: translateY(1px); }
        #game-container { width: 100vw; height: 100vh; border: none; background-color: var(--dark-color); position: relative; overflow: hidden; }
        
        /* å…¨æ–°çš„é ‚éƒ¨ UI å®¹å™¨ */
        #top-ui-bar {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px; /* å»¶ä¼¸åˆ°æ•´å€‹å¯¬åº¦ */
            display: flex;
            justify-content: space-between; /* å·¦å³å…©ç«¯å°é½Š */
            align-items: center;
            gap: 15px; /* å…§éƒ¨å…ƒç´ é–“è· */
            z-index: 20; /* ç¢ºä¿åœ¨æœ€ä¸Šå±¤ */
            pointer-events: none; /* é è¨­ä¸é˜»æ“‹ä¸‹æ–¹é»æ“Š */
        }
        #top-ui-bar > div, #top-ui-bar > button { /* è®“ UI å…ƒç´ å¯ä»¥è¢«é»æ“Š/äº’å‹• */
            pointer-events: auto;
        }

        #bomb-counter, #dart-counter { 
            background-color: rgba(0,0,0,0.5); padding: 8px 15px; border-radius: 8px; font-size: 1.5em; display: flex; align-items: center; gap: 8px; 
        }
        #bomb-count-text, #dart-count-text { font-weight: bold; }

        /* é¡¯ç¤ºæ‰¾åˆ°çš„å­—æ¨£ (ç¾åœ¨åœ¨ #top-ui-bar å…§ï¼Œä¸å†æ˜¯çµ•å°å®šä½) */
        #found-chars-display {
            background-color: rgba(0,0,0,0.5);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--treasure-color);
            font-weight: bold;
            /* é€™äº›å±¬æ€§æœƒè¢« flexbox çˆ¶å…ƒç´ ç®¡ç† */
            /* position: absolute; top: 15px; left: 15px; */ 
        }
        #found-chars-display span {
            min-width: 1em; /* ç¢ºä¿å­—ç¬¦æœ‰è¶³å¤ çš„ç©ºé–“ */
            text-align: center;
            display: inline-block;
        }

        #place-bomb-btn, #shoot-dart-btn { /* Combined styles for both action buttons */
            position: absolute;
            width: 70px; height: 70px;
            border-radius: 50%;
            font-size: 2.5em; padding: 0;
            z-index: 100;
            background-color: rgba(52, 73, 94, 0.7);
            display: flex; /* Always display for desktop, controlled for touch by JS */
            justify-content: center; align-items: center;
        }
        #place-bomb-btn { bottom: 40px; right: 40px; }
        #shoot-dart-btn { bottom: 120px; right: 40px; } /* Positioned above bomb button */

        #place-bomb-btn:hover:not(:disabled),
        #shoot-dart-btn:hover:not(:disabled) { background-color: rgba(44, 62, 80, 1); }

        #maze { position: absolute; display: grid; }
        #player { width: var(--player-size); height: var(--player-size); background-size: cover; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .monster { width: var(--player-size); height: var(--player-size); background-size: cover; border-radius: 8px; position: absolute; z-index: 9; transition: transform 0.1s linear, filter 0.5s ease, opacity 0.5s ease; opacity: 0; }
        .monster.visible { opacity: 1; }
        
        /* çµ±ä¸€ä¸­å¿ƒå®šä½ï¼ŒJS åªè² è²¬è¨­å®š left/top */
        .bomb, .explosion, .dart, .treasure {
            position: absolute;
            width: var(--cell-size);
            height: var(--cell-size);
            display: flex;
            justify-content: center;
            align-items: center;
            transform: translate(-50%, -50%); /* ä¿æŒå…ƒç´ ä¸­å¿ƒåœ¨æ ¼å­ä¸­å¿ƒ */
            box-sizing: border-box; /* ç¢ºä¿ padding/border ä¸æœƒæ’å¤§å…ƒç´  */
        }
        .bomb { font-size: 28px; opacity: 0.9; z-index: 7; }
        /* çˆ†ç‚¸ç‰¹æ•ˆæ¨£å¼ */
        .explosion { font-size: 36px; z-index: 50; pointer-events: none; animation: explosion-anim 0.5s ease-out forwards; }
        @keyframes explosion-anim { from { transform: scale(0.5); opacity: 1; } to { transform: scale(2); opacity: 0; } }

        /* é£›é¢æ¨£å¼ */
        .dart {
            font-size: 2em; /* Dart emoji size */
            z-index: 12; /* Above player/monsters */
            transition: none; /* Dart should not animate with transform */
        }
        
        /* å¯¶è—å…ƒç´ æ¨£å¼ */
        .treasure {
            width: var(--player-size);
            height: var(--player-size);
            z-index: 8;
            opacity: 0; /* Initially hidden, becomes visible with FOV */
            background-color: var(--treasure-color); /* Add a background */
            border-radius: 50%; /* Make it round */
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            color: var(--primary-bg); /* Text color contrasting with background */
            font-weight: bold;
        }
        .treasure.visible {
            opacity: 1;
            transition: var(--visible-transition);
        }
        /* å·²æ‰¾åˆ°çš„å¯¶è—ï¼Œé€æ˜åº¦é™ä½ */
        .treasure.found-item {
            opacity: 0.5;
            transition: opacity 0.5s ease;
        }

        .grid-cell { width: var(--cell-size); height: var(--cell-size); transition: var(--visible-transition); }
        .wall { background-color: var(--wall-color); opacity: 0.5; }
        .path, .start, .treasure-location { background-color: var(--dark-color); }
        .grid-cell.visible:not(.wall) { background-color: var(--path-color); }
        .grid-cell.start.visible { background-color: var(--start-color); }
        .grid-cell.treasure-location.visible { background-color: var(--treasure-color); }
        
        /* å‹åˆ©ç•«é¢ä½ˆå±€ */
        #win-screen {
            position: relative;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Hide confetti overflow */
            background-color: transparent; /* MODIFIED: Make screen transparent to see video */
        }
        #riddle-box {
            background: rgba(0,0,0,0.7); /* Make background darker for contrast */
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            position: relative; /* Ensure it's above canvas */
            z-index: 1;
        } 

        #joystick-container { position: absolute; bottom: 40px; left: 40px; width: 150px; height: 150px; display: none; z-index: 100; user-select: none; -webkit-user-select: none; }
        #joystick-base { position: relative; width: 100%; height: 100%; background-color: rgba(52, 73, 94, 0.5); border-radius: 50%; border: 3px solid rgba(236, 240, 241, 0.5); }
        #joystick-handle { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background-color: rgba(52, 152, 219, 0.8); border-radius: 50%; transform: translate(-50%, -50%); transition: transform 0.1s ease-out; }
        .notification-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); display: none; justify-content: center; align-items: center; z-index: 1000; animation: fadeIn 0.3s ease; }
        .notification-overlay.active { display: flex; }
        .notification-box { background: var(--primary-bg); padding: 20px 30px; border-radius: 15px; text-align: center; max-width: 90%; width: 450px; border: 2px solid var(--button-bg); box-shadow: 0 5px 15px rgba(0,0,0,0.5); transform: scale(0.9); opacity: 0; transition: transform 0.3s ease-out, opacity 0.3s ease-out; }
        .notification-overlay.active .notification-box { transform: scale(1); opacity: 1; }
        .notification-box p { font-size: 1.3em; margin-bottom: 25px; color: var(--text-color); }
        
        /* å½©å¸¶canvas */
        #confetti-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* Behind riddle-box */
            pointer-events: none; /* Allow clicks on buttons beneath */
        }

        /* éŠæˆ²çµæŸç•«é¢å½±ç‰‡èƒŒæ™¯ - å…¨å±€å®šä½ */
        #background-video { /* Changed ID to be generic for background video */
            position: fixed; /* Use fixed for full viewport coverage */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Cover the entire area */
            z-index: -2; /* Ensure it's behind all screen content */
            opacity: 0; /* Initially hidden */
            transition: opacity 0.5s ease; /* Smooth fade in/out */
            pointer-events: none; /* Do not block mouse events */
        }

        /* ç¢ºä¿çµæŸç•«é¢çš„æ–‡å­—å’ŒæŒ‰éˆ•åœ¨å½±ç‰‡ä¹‹ä¸Šä¸”å¯è®€ */
        #game-over-screen h1,
        #game-over-screen p,
        #game-over-screen .button {
            position: relative; /* å°‡é€™äº›å…ƒç´ æå‡åˆ°å½±ç‰‡ä¸Šæ–¹ */
            z-index: 1;
            background: rgba(0,0,0,0.6); /* çµ¦å…§å®¹ä¸€å€‹åŠé€æ˜èƒŒæ™¯ä»¥æé«˜å¯è®€æ€§ */
            padding: 15px 30px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <!-- å…¨å±€èƒŒæ™¯å½±ç‰‡ï¼Œé€šéJSæ§åˆ¶å…¶é€æ˜åº¦ä¾†é¡¯ç¤º/éš±è— -->
    <video id="background-video" autoplay loop muted playsinline>
        <source src="images/gameover_bg.mp4" type="video/mp4">
        æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æŒå½±ç‰‡æ’­æ”¾ã€‚
    </video>

    <div id="start-screen" class="screen active"><h1>çˆ¶è¦ªç¯€å¤§å†’éšª</h1><h2>è¦ªæ„›çš„çˆ¸çˆ¸ï¼Œçˆ¶è¦ªç¯€å¿«æ¨‚ï¼</h2><p>åœ¨è¿·å®®æ·±è™•ï¼Œè—è‘—ä¸€ä»½çµ¦ä½ çš„çˆ¶è¦ªç¯€é©šå–œ...<br>è«‹å‹‡æ•¢åœ°å»å°‹æ‰¾å®ƒå§ï¼</p><button id="start-game-btn" class="button">é–‹å§‹å†’éšªï¼</button></div>
    <div id="game-screen" class="screen">
        <div id="game-container">
            <div id="maze"></div>
            <div id="player"></div>
            <!-- å…¨æ–°çš„é ‚éƒ¨ UI å®¹å™¨ï¼Œæ•´åˆäº†æ‰€æœ‰è¨ˆæ•¸å™¨å’Œæ–‡å­—é¡¯ç¤º -->
            <div id="top-ui-bar">
                <div id="found-chars-display">
                    <span id="char-0">_</span><span id="char-1">_</span><span id="char-2">_</span>
                </div>
                <!-- å°‡ç‚¸å½ˆå’Œé£›é¢è¨ˆæ•¸å™¨åŒ…è£åœ¨ä¸€å€‹ div ä¸­ï¼Œä»¥ä¾¿åœ¨ flex å®¹å™¨ä¸­çµ±ä¸€å³å°é½Š -->
                <div style="display: flex; gap: 15px;">
                    <div id="bomb-counter">ğŸ’£<span id="bomb-count-text">10</span></div>
                    <div id="dart-counter">ğŸªƒ<span id="dart-count-text">5</span></div>
                </div>
            </div>

            <div id="joystick-container"><div id="joystick-base"><div id="joystick-handle"></div></div></div>
            <button id="place-bomb-btn" class="button">ğŸ’£</button>
            <button id="shoot-dart-btn" class="button">ğŸªƒ</button> <!-- æ–°å¢é£›é¢æŒ‰éˆ• -->
        </div>
    </div>
    <div id="win-screen" class="screen">
        <canvas id="confetti-canvas"></canvas> <!-- æ–°å¢ï¼šå½©å¸¶canvas -->
        <div id="riddle-box">
            <h1>æ­å–œï¼ä½ æ‰¾åˆ°äº†å…¨éƒ¨ç¦®ç‰©ï¼</h1>
            <p>è¦ªæ„›çš„çˆ¸çˆ¸ï¼Œç¥æ‚¨çˆ¶è¦ªç¯€å¿«æ¨‚ï¼</p>
            <p style="color: var(--treasure-color); font-weight: bold; font-size: 1.4em;">
                æ„Ÿè¬æ‚¨ä¸€ç›´ä»¥ä¾†ç‚ºå®¶åº­å¸¶ä¾†çš„<br>
                æº«æš–ã€å®‰å…¨èˆ‡æ™ºæ…§ï¼<br>
                ç¥æ‚¨å¥åº·å¹³å®‰ã€äº‹äº‹é †å¿ƒï¼
            </p>
            <button id="back-to-menu-from-win-btn" class="button">å›åˆ°é–‹å§‹ç•«é¢</button>
        </div>
    </div>
    <div id="game-over-screen" class="screen">
        <!-- å½±ç‰‡ç¾åœ¨æ˜¯å…¨å±€èƒŒæ™¯ï¼Œä¸å†æ˜¯æ­¤divçš„å­å…ƒç´  -->
        <h1>å“å‘€ï¼è¢«æŠ“åˆ°äº†ï¼</h1>
        <p>åˆ¥ç°å¿ƒï¼Œå†’éšªç¸½æ˜¯å……æ»¿æŒ‘æˆ°ï¼Œæ­£å¦‚äººç”Ÿä¸€èˆ¬ã€‚</p>
        <button id="retry-btn" class="button">æ²’å•é¡Œï¼Œæ€éº¼å¯èƒ½æœƒæ”¾æ£„ï¼</button><button id="back-to-menu-btn" class="button">å›åˆ°é–‹å§‹ç•«é¢</button></div>
    <div id="notification-overlay" class="notification-overlay"><div id="notification-box"><p id="notification-text"></p><button id="notification-close-btn" class="button">äº†è§£ï¼</button></div></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- è®Šæ•¸å®£å‘Šå€ ---
    const screens = { start: document.getElementById('start-screen'), game: document.getElementById('game-screen'), win: document.getElementById('win-screen'), gameOver: document.getElementById('game-over-screen') };
    const mazeEl = document.getElementById("maze"), playerEl = document.getElementById("player"), gameContainer = document.getElementById("game-container"), joystickContainer = document.getElementById("joystick-container"), joystickHandle = document.getElementById("joystick-handle");
    const bombCountTextSpan = document.getElementById("bomb-count-text"), placeBombBtn = document.getElementById("place-bomb-btn");
    const dartCountTextSpan = document.getElementById("dart-count-text"), shootDartBtn = document.getElementById("shoot-dart-btn");
    const notificationOverlay = document.getElementById("notification-overlay"), notificationText = document.getElementById("notification-text"), notificationCloseBtn = document.getElementById("notification-close-btn");
    const backgroundVideo = document.getElementById("background-video"); // å½±ç‰‡å…ƒç´ æ”¹ç‚ºå…¨å±€ID

    // æ‰¾åˆ°çš„å­—æ¨£ UI å…ƒç´ 
    const foundCharsDisplay = document.getElementById("found-chars-display");
    const charSpans = [
        document.getElementById("char-0"),
        document.getElementById("char-1"),
        document.getElementById("char-2")
    ];

    // --- éŠæˆ²ç‹€æ…‹èˆ‡è¨­å®š ---
    const TREASURE_CHARS = ["å®‰", "å…¨", "å¸½"];
    let foundCharactersPersistent = new Array(TREASURE_CHARS.length).fill(false);

    let gameState = {
        mazeData: [], playerPos: { x: 0, y: 0 }, treasures: [], monsters: [],
        bombsRemaining: 0, placedBombs: [], dartsRemaining: 0, activeDarts: [],
        foundTreasuresCount: 0, foundChars: ['', '', ''], playerLastDirection: 'right',
    };
    let gameSession = { currentMoveSpeed: 120, isPaused: false };
    
    let playerMovement = {
        activeKeyboardDirections: new Set(), joystickDirection: null,
        currentExecutingDirection: null, nextDesiredDirection: null,
        moveInterval: null, lastPos: { x: -1, y: -1 }
    };
    
    const levelConfig = { w: 15, h: 10, m: 5, initialBombs: 10, initialDarts: 5 };
    const FOV_RADIUS = 10;
    const MONSTER_TIERS = [ 
        {level:1,colorFilter:"hue-rotate(0deg) saturate(0.8)",speed:1500},
        {level:2,colorFilter:"hue-rotate(90deg) saturate(1.2)",speed:1200}, 
        {level:3,colorFilter:"hue-rotate(200deg) saturate(1.5)",speed:900} 
    ];
    let isTouchDevice = false;

    // å½©å¸¶ç‰¹æ•ˆç›¸é—œè®Šæ•¸
    let confettiCanvas, confettiCtx, confettiParticles = [], confettiAnimationId;
    let burstSequenceTimerId; 
    const emitterYPositions = [0.2, 0.5, 0.8]; 
    const burstOrderIndices = [2, 1, 0]; // å¾ä¸‹å¾€ä¸Š
    let currentBurstIndexInRound = 0; 
    const burstBetweenPairsDelayMs = 200;
    const delayBetweenRoundsMs = 2000;

    // --- æ ¸å¿ƒåŠŸèƒ½ ---
    function showScreen(screenName) { 
        Object.values(screens).forEach(s => s.classList.remove('active')); 
        if(screens[screenName]) {
            screens[screenName].classList.add('active');
            // MODIFIED: æ§åˆ¶å…¨å±€èƒŒæ™¯å½±ç‰‡çš„é¡¯ç¤ºèˆ‡æ’­æ”¾
            if (screenName === 'gameOver' || screenName === 'win') {
                backgroundVideo.style.opacity = '1';
                backgroundVideo.play().catch(e => console.log("Video play failed:", e));
            } else {
                backgroundVideo.style.opacity = '0';
                backgroundVideo.pause();
                backgroundVideo.currentTime = 0;
            }
        }
    }
    function seededRandom(seed) { let state = seed % 2147483647; if (state <= 0) state += 2147483646; return function() { state = state * 16807 % 2147483647; return (state - 1) / 2147483646; } }

    // --- éŠæˆ²ä¸»å¾ªç’° ---
    function mainGameLoop() {
        if (gameSession.isPaused) return;

        updatePlayerMovementIntents();

        let finalMoveDirection = null;

        if (playerMovement.nextDesiredDirection && canMove(gameState.playerPos, playerMovement.nextDesiredDirection)) {
            finalMoveDirection = playerMovement.nextDesiredDirection;
            playerMovement.currentExecutingDirection = finalMoveDirection;
            playerMovement.nextDesiredDirection = null;
        } else if (playerMovement.currentExecutingDirection && canMove(gameState.playerPos, playerMovement.currentExecutingDirection)) {
            finalMoveDirection = playerMovement.currentExecutingDirection;
        } else {
            playerMovement.currentExecutingDirection = null;
            playerMovement.nextDesiredDirection = null;
        }

        if (finalMoveDirection) {
            let newPos = { ...gameState.playerPos };
            if (finalMoveDirection === 'up') newPos.y--; else if (finalMoveDirection === 'down') newPos.y++; else if (finalMoveDirection === 'left') newPos.x--; else if (finalMoveDirection === 'right') newPos.x++;
            gameState.playerPos = newPos;
            centerViewOnPlayer(true);
            gameState.playerLastDirection = finalMoveDirection;
        }
        
        if (playerMovement.lastPos.x !== gameState.playerPos.x || playerMovement.lastPos.y !== gameState.playerPos.y) {
            computeFov();
            updateFovDisplay();
            playerMovement.lastPos = {...gameState.playerPos};
        }
        
        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size').trim());
        for (const monster of gameState.monsters) { 
            if (!visibleCells.has(`${monster.pos.x},${monster.pos.y}`) && monster.state === "CHASING" && !monster.lastKnownPlayerPos) {
                 monster.state = "RETURNING"; 
            }
            monster.moveCooldown += gameSession.currentMoveSpeed;
            if (monster.moveCooldown >= monster.speed) { 
                updateSingleMonsterAI(monster);
                const monsterEl = document.getElementById(`monster-${monster.id}`);
                if (monsterEl) monsterEl.style.transform = `translate(${monster.pos.x * cellSize}px, ${monster.pos.y * cellSize}px)`;
                monster.moveCooldown = 0; 
            }
        }
        
        checkBombCollisions();
        checkPlayerPosition();
    }

    // --- æ–°å¢ï¼šæ ¹æ“šæ‰€æœ‰è¼¸å…¥æ›´æ–°ç©å®¶ç§»å‹•æ„åœ–çš„ç‹€æ…‹æ©Ÿ ---
    function updatePlayerMovementIntents() {
        let highestPriorityInputDirection = null;
        const priorityOrder = ['up', 'down', 'left', 'right'];

        if (playerMovement.joystickDirection) {
            highestPriorityInputDirection = playerMovement.joystickDirection;
        } else {
            for (const dir of priorityOrder) {
                if (playerMovement.activeKeyboardDirections.has(dir)) {
                    highestPriorityInputDirection = dir;
                    break;
                }
            }
        }

        if (highestPriorityInputDirection === null) {
            playerMovement.nextDesiredDirection = null;
        } else if (playerMovement.currentExecutingDirection === null) {
            playerMovement.currentExecutingDirection = highestPriorityInputDirection;
            playerMovement.nextDesiredDirection = null;
        } else if (highestPriorityInputDirection !== playerMovement.currentExecutingDirection) {
            playerMovement.nextDesiredDirection = highestPriorityInputDirection;
        } else {
            playerMovement.nextDesiredDirection = null;
        }
    }
    
    function pauseGame() { gameSession.isPaused = true; }
    function resumeGame() { gameSession.isPaused = false; }

    // --- æ€ªç‰© AI ---
    function updateSingleMonsterAI(monster) {
        const playerVisible = isPlayerVisible(monster.pos, gameState.playerPos);
        switch (monster.state) {
            case "IDLE": if(playerVisible) monster.state="CHASING"; break;
            case "CHASING": if(playerVisible) { monster.lastKnownPlayerPos={...gameState.playerPos} } else { monster.state="SEARCHING" } break;
            case "SEARCHING": if(playerVisible) { monster.state="CHASING" } else if(monster.pos.x===monster.lastKnownPlayerPos?.x&&monster.pos.y===monster.lastKnownPlayerPos?.y) { monster.state="RETURNING" } break;
            case "RETURNING": if(monster.pos.x===monster.spawnPos.x&&monster.pos.y===monster.spawnPos.y) { monster.state="IDLE" } break;
        }
        let targetPos = null;
        if(monster.state==="CHASING") targetPos = gameState.playerPos;
        else if(monster.state==="SEARCHING") targetPos = monster.lastKnownPlayerPos;
        else if(monster.state==="RETURNING") targetPos = monster.spawnPos;
        
        if (targetPos) { 
            const path = findPath(monster.pos, targetPos); 
            if (path && path.length > 1) { 
                monster.pos = path[1]; 
            } else if (monster.state === "SEARCHING" && !path) {
                monster.state = "RETURNING";
            }
        }
    }

    function checkPlayerPosition() {
        if (gameSession.isPaused) return;

        for (let i = 0; i < gameState.treasures.length; i++) {
            const treasure = gameState.treasures[i];
            if (!treasure.found && gameState.playerPos.x === treasure.pos.x && gameState.playerPos.y === treasure.pos.y) {
                treasure.found = true;
                gameState.foundTreasuresCount++;
                
                const charIndex = TREASURE_CHARS.indexOf(treasure.originalChar);
                if (charIndex !== -1) {
                    gameState.foundChars[charIndex] = treasure.originalChar;
                    foundCharactersPersistent[charIndex] = true;
                    updateFoundCharsDisplay();
                }
                
                const treasureEl = document.getElementById(treasure.id);
                if (treasureEl) {
                    treasureEl.textContent = 'ğŸ“¦';
                    treasureEl.classList.add('found-item');
                }
                
                showNotification(`æ­å–œä½ æ‰¾åˆ°äº†ã€Œ${treasure.originalChar}ã€ï¼`);
                
                if (foundCharactersPersistent.every(isFound => isFound)) {
                    winGame();
                    return;
                }
            }
        }

        for (const monster of gameState.monsters) { 
            if (monster.pos.x === gameState.playerPos.x && monster.pos.y === gameState.playerPos.y) { 
                gameOver(); 
                return; 
            } 
        }
    }

    // --- éŠæˆ²æµç¨‹ ---
    function winGame() { 
        clearGameListeners(); 
        showScreen("win"); 
        initConfetti();
        triggerNextConfettiBurstSequence();
    }
    function gameOver() { clearGameListeners(); showScreen("gameOver"); }

    function startGame(resetPersistent = true) {
        clearGameListeners();
        
        gameState.bombsRemaining = levelConfig.initialBombs;
        gameState.placedBombs = [];
        gameState.dartsRemaining = levelConfig.initialDarts;
        gameState.activeDarts = [];
        gameState.foundTreasuresCount = 0;
        gameState.foundChars = ['', '', ''];
        gameState.playerLastDirection = 'right';

        playerMovement.activeKeyboardDirections.clear();
        playerMovement.joystickDirection = null;
        playerMovement.currentExecutingDirection = null;
        playerMovement.nextDesiredDirection = null;
        playerMovement.lastPos = { x: -1, y: -1 };


        if (resetPersistent) {
            foundCharactersPersistent.fill(false);
        }

        TREASURE_CHARS.forEach((char, index) => {
            if (foundCharactersPersistent[index]) {
                gameState.foundChars[index] = char;
            }
        });
        gameState.foundTreasuresCount = foundCharactersPersistent.filter(Boolean).length;


        updateBombUI();
        updateDartUI();
        updateFoundCharsDisplay();
        
        gameSession = { currentMoveSpeed: 120, isPaused: false };
        const playerSeed = 'Yen-Lin-Birthday-Hero';
        playerEl.style.backgroundImage = `url(https://api.dicebear.com/8.x/adventurer/svg?seed=${playerSeed}&radius=50)`;
        
        renderMaze();
        computeFov();
        updateFovDisplay();
        showScreen('game');
        centerViewOnPlayer(false);
        
        document.addEventListener('keydown', handleKeyDown); 
        document.addEventListener('keyup', handleKeyUp);
        setupGameUIForDevice(); 
        playerMovement.moveInterval = setInterval(mainGameLoop, gameSession.currentMoveSpeed);

        setTimeout(() => {
            showNotification(`çˆ¶è¦ªç¯€å¿«æ¨‚ï¼æ‰¾åˆ°ä¸‰å€‹éš±è—çš„ç¦®ç‰©ï¼Œå³å¯é€šé—œï¼ä¸¦ç‚ºä½ æº–å‚™äº†${levelConfig.initialBombs}å€‹ç‚¸å½ˆ (æŒ‰ç©ºç™½éµæˆ–é»æ“Šå³ä¸‹è§’æŒ‰éˆ•ä½¿ç”¨)ï¼Œä»¥åŠ${levelConfig.initialDarts}å€‹é£›é¢ (æŒ‰ F éµæˆ–é»æ“Šå³ä¸‹è§’æŒ‰éˆ•ä½¿ç”¨)ï¼`);
        }, 500);
    }
    
    // --- è¿·å®®ç”Ÿæˆèˆ‡æ¸²æŸ“ ---
    function renderMaze() {
        mazeEl.innerHTML = "";
        gameState.monsters = [];
        gameState.treasures = [];
        gameState.mazeData = generateMaze(levelConfig.w, levelConfig.h, Date.now());
        placeTreasureAndMonsters();

        const mazeWidth = gameState.mazeData[0].length;
        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size').trim());
        mazeEl.style.gridTemplateColumns = `repeat(${mazeWidth}, ${cellSize}px)`;
        let content = "";
        gameState.mazeData.forEach((row, y) => {
            row.forEach((cellType, x) => {
                let cellClass = "";
                if (cellType === "S") { gameState.playerPos = { x, y }; cellClass = "start"; }
                else if (cellType === "W") cellClass = "wall";
                else if (cellType === "P") cellClass = "path";
                else if (cellType === "T") { cellClass = "treasure-location"; }
                content += `<div class="grid-cell ${cellClass}" id="cell-${x}-${y}"></div>`;
            })
        });
        mazeEl.innerHTML = content;
        
        for (const monster of gameState.monsters) {
            const el = document.createElement("div");
            el.id = `monster-${monster.id}`;
            el.className = "monster";
            el.style.backgroundImage = `url(https://api.dicebear.com/8.x/bottts-neutral/svg?seed=${monster.id}&radius=8&backgroundColor=d1d1d1)`;
            el.style.transform = `translate(${monster.pos.x * cellSize}px, ${monster.pos.y * cellSize}px)`;
            el.style.filter = monster.colorFilter;
            mazeEl.appendChild(el);
        }

        for (const treasure of gameState.treasures) {
            if (!treasure.pos) {
                console.warn(`Treasure ${treasure.originalChar} has no position and will not be rendered.`);
                continue; 
            }
            const el = document.createElement("div");
            el.id = treasure.id;
            el.className = "treasure";
            el.textContent = treasure.displayChar;
            el.style.left = `${treasure.pos.x * cellSize + cellSize / 2}px`;
            el.style.top = `${treasure.pos.y * cellSize + cellSize / 2}px`;
            if (treasure.found) {
                el.classList.add('found-item');
            }
            mazeEl.appendChild(el);
        }
    }

    // --- æ€ªç‰©èˆ‡å¯¶ç®±æ”¾ç½® ---
    function placeTreasureAndMonsters() {
        const rng = seededRandom(Date.now());
        let allDeadEnds = [];

        for (let y = 1; y < gameState.mazeData.length - 1; y++) {
            for (let x = 1; x < gameState.mazeData[y].length - 1; x++) {
                if (gameState.mazeData[y][x] === 'P') {
                    let wallCount = 0;
                    if (gameState.mazeData[y-1][x] === 'W') wallCount++;
                    if (gameState.mazeData[y+1][x] === 'W') wallCount++;
                    if (gameState.mazeData[y][x-1] === 'W') wallCount++;
                    if (gameState.mazeData[y][x+1] === 'W') wallCount++;
                    if (wallCount >= 3) {
                        if (getDistance({ x, y }, { x: 1, y: 1 }) > 5) {
                            allDeadEnds.push({x, y});
                        }
                    }
                }
            }
        }
        allDeadEnds.sort(() => rng() - 0.5);

        gameState.treasures = [];
        const treasuresToPlaceInThisRound = [];
        const treasuresAlreadyFound = [];

        TREASURE_CHARS.forEach((char, index) => {
            if (!foundCharactersPersistent[index]) {
                treasuresToPlaceInThisRound.push({ originalChar: char, id: `treasure-${char}`, found: false, displayChar: 'ğŸ' });
            } else {
                treasuresAlreadyFound.push({ originalChar: char, id: `treasure-${char}`, found: true, displayChar: 'ğŸ“¦' });
            }
        });
        
        treasuresToPlaceInThisRound.sort(() => rng() - 0.5);

        for (const t of treasuresToPlaceInThisRound) {
            if (allDeadEnds.length > 0) {
                const tPos = allDeadEnds.pop();
                t.pos = tPos;
                gameState.mazeData[tPos.y][tPos.x] = "T";
                gameState.treasures.push(t);
            } else {
                console.warn(`WARN: Not enough dead ends to place new treasure: ${t.originalChar}. It will not appear this round.`);
            }
        }

        for (const t of treasuresAlreadyFound) {
            if (allDeadEnds.length > 0) {
                const tPos = allDeadEnds.pop();
                t.pos = tPos;
                gameState.mazeData[tPos.y][tPos.x] = "T";
                gameState.treasures.push(t);
            } else {
                console.warn(`WARN: Not enough dead ends for already found treasure: ${t.originalChar}. It will not appear on the map.`);
            }
        }

        gameState.monsters = [];
        for (let i = 0; i < levelConfig.m; i++) {
            if (allDeadEnds.length > 0) {
                const spawnPoint = allDeadEnds.pop();
                const tier = MONSTER_TIERS[Math.floor(rng() * MONSTER_TIERS.length)];
                gameState.monsters.push({ ...tier, id: i, pos: { ...spawnPoint }, spawnPos: { ...spawnPoint }, state: 'IDLE', lastKnownPlayerPos: null, moveCooldown: 0 });
            } else {
                console.warn(`WARN: Not enough dead ends left for all ${levelConfig.m} monsters. Placed ${i} monsters.`);
                break;
            }
        }
    }

    function generateMaze(w, h, seed) {
        const rng = seededRandom(seed);
        const grid = Array.from({ length: h * 2 + 1 }, () => Array(w * 2 + 1).fill("W"));
        function carve(cx, cy) { const dirs = ["N", "S", "E", "W"].sort(() => rng() - .5); for (const d of dirs) { const[dx,dy]={N:[0,-2],S:[0,2],E:[2,0],W:[-2,0]}[d]; const nx=cx+dx, ny=cy+dy; if(ny>=0&&ny<h*2+1&&nx>=0&&nx<w*2+1&&grid[ny][nx]==="W"){grid[ny-dy/2][nx-dx/2]="P";grid[ny][nx]="P";carve(nx,ny)} } }
        grid[1][1] = "P"; carve(1, 1); grid[1][1] = "S"; return grid;
    }

    // --- ç‚¸å½ˆèˆ‡çˆ†ç‚¸åŠŸèƒ½ ---
    function placeBomb() {
        if (gameSession.isPaused) return;
        if (gameState.bombsRemaining <= 0) {
            showNotification("ä½ æ²’æœ‰ç‚¸å½ˆäº†ï¼");
            return;
        }
        const {x, y} = gameState.playerPos;
        if (gameState.placedBombs.some(bomb => bomb.x === x && bomb.y === y)) {
            showNotification("é€™å€‹ä½ç½®å·²ç¶“æœ‰ç‚¸å½ˆäº†ï¼");
            return;
        }

        gameState.bombsRemaining--;
        updateBombUI();
        
        const bombPos = {x, y};
        gameState.placedBombs.push(bombPos);

        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size').trim());
        const bombEl = document.createElement('div');
        bombEl.id = `bomb-${bombPos.x}-${bombPos.y}`;
        bombEl.className = 'bomb';
        bombEl.textContent = 'ğŸ’£';
        bombEl.style.left = `${bombPos.x * cellSize + cellSize / 2}px`;
        bombEl.style.top = `${bombPos.y * cellSize + cellSize / 2}px`;
        mazeEl.appendChild(bombEl);
    }
    
    function updateBombUI() { bombCountTextSpan.textContent = gameState.bombsRemaining; }

    function triggerExplosion(x, y) {
        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size').trim());
        const explosionEl = document.createElement('div');
        explosionEl.className = 'explosion';
        explosionEl.textContent = 'ğŸ’¥';
        explosionEl.style.left = `${x * cellSize + cellSize / 2}px`;
        explosionEl.style.top = `${y * cellSize + cellSize / 2}px`;
        mazeEl.appendChild(explosionEl);
        setTimeout(() => { explosionEl.remove(); }, 500);
    }

    function checkBombCollisions() {
        const monstersToRemove = new Set();
        const bombsToRemove = [];

        for (const monster of gameState.monsters) {
            const bombIndex = gameState.placedBombs.findIndex(b => b.x === monster.pos.x && b.y === monster.pos.y);
            if (bombIndex > -1) {
                monstersToRemove.add(monster.id);
                const bombPos = gameState.placedBombs[bombIndex];
                bombsToRemove.push(bombPos);
                triggerExplosion(bombPos.x, bombPos.y);
            }
        }

        if (monstersToRemove.size > 0) {
            gameState.monsters = gameState.monsters.filter(m => !monstersToRemove.has(m.id));
            monstersToRemove.forEach(id => document.getElementById(`monster-${id}`)?.remove());

            gameState.placedBombs = gameState.placedBombs.filter(b => !bombsToRemove.some(br => br.x === b.x && br.y === b.y));
            bombsToRemove.forEach(b => document.getElementById(`bomb-${b.x}-${b.y}`)?.remove());
        }
    }

    // --- é£›é¢åŠŸèƒ½ ---
    function updateDartUI() { dartCountTextSpan.textContent = gameState.dartsRemaining; }

    function shootDart() {
        if (gameSession.isPaused) return;
        if (gameState.dartsRemaining <= 0) {
            showNotification("ä½ æ²’æœ‰é£›é¢äº†ï¼");
            return;
        }
        const dartDirection = gameState.playerLastDirection;

        gameState.dartsRemaining--;
        updateDartUI();

        let dartPos = { ...gameState.playerPos };
        const dartId = `dart-${Date.now()}`;
        const dartEl = document.createElement('div');
        dartEl.id = dartId;
        dartEl.className = 'dart';
        dartEl.textContent = 'ğŸªƒ';
        mazeEl.appendChild(dartEl);

        const dart = { id: dartId, pos: dartPos, direction: dartDirection, element: dartEl, intervalId: null };
        gameState.activeDarts.push(dart);

        const dartMoveSpeed = gameSession.currentMoveSpeed / 3;

        dart.intervalId = setInterval(() => {
            if (gameSession.isPaused) return;

            let nextPos = { ...dart.pos };
            if (dart.direction === 'up') nextPos.y--;
            else if (dart.direction === 'down') nextPos.y++;
            else if (dart.direction === 'left') nextPos.x--;
            else if (dart.direction === 'right') nextPos.x++;

            const mazeHeight = gameState.mazeData.length;
            const mazeWidth = gameState.mazeData[0].length;
            if (nextPos.x < 0 || nextPos.x >= mazeWidth ||
                nextPos.y < 0 || nextPos.y >= mazeHeight ||
                gameState.mazeData[nextPos.y][nextPos.x] === "W") {
                clearInterval(dart.intervalId);
                dart.element.remove();
                gameState.activeDarts = gameState.activeDarts.filter(d => d.id !== dart.id);
                return;
            }

            dart.pos = nextPos;
            const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size').trim());
            dart.element.style.left = `${dart.pos.x * cellSize + cellSize / 2}px`;
            dart.element.style.top = `${dart.pos.y * cellSize + cellSize / 2}px`;

            const monsterHitIndex = gameState.monsters.findIndex(m => m.pos.x === dart.pos.x && m.pos.y === dart.pos.y);
            if (monsterHitIndex !== -1) {
                const monsterId = gameState.monsters[monsterHitIndex].id;
                document.getElementById(`monster-${monsterId}`)?.remove();
                gameState.monsters.splice(monsterHitIndex, 1);
                clearInterval(dart.intervalId);
                dart.element.remove();
                gameState.activeDarts = gameState.activeDarts.filter(d => d.id !== dart.id);
                showNotification("æ€ªç‰©è¢«é£›é¢æ¶ˆæ»…äº†ï¼");
                return;
            }
        }, dartMoveSpeed);
    }


    // --- é€šçŸ¥åŠŸèƒ½ ---
    function showNotification(message) { pauseGame(); notificationText.innerHTML = message; notificationOverlay.classList.add('active'); }
    function hideNotification() { notificationOverlay.classList.remove('active'); resumeGame(); }

    // --- æ›´æ–°æ‰¾åˆ°çš„å­—æ¨£ UI ---
    function updateFoundCharsDisplay() {
        charSpans.forEach((span, index) => {
            span.textContent = gameState.foundChars[index] || '_';
        });
    }

    // --- å½©å¸¶ç‰¹æ•ˆåŠŸèƒ½ ---
    function initConfetti() {
        confettiCanvas = document.getElementById('confetti-canvas');
        if (!confettiCanvas) return; 
        confettiCtx = confettiCanvas.getContext('2d');
        resizeConfettiCanvas();
        window.addEventListener('resize', resizeConfettiCanvas);
        if (!confettiAnimationId) {
            drawConfetti();
        }
    }

    function resizeConfettiCanvas() {
        if (confettiCanvas) {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        }
    }

    function createConfettiParticle(spawnX, spawnY, initialSide) {
        const radius = Math.random() * 5 + 2;
        const colors = ['#f1c40f', '#e67e22', '#e74c3c', '#2ecc71', '#3498db', '#9b59b6'];
        const color = colors[Math.floor(Math.random() * colors.length)];
        
        const initialHorizontalBurstSpeed = Math.random() * 12 + 8;
        const initialVerticalBurstSpeed = Math.random() * -10 - 5;
        
        const velocityX = initialHorizontalBurstSpeed * (initialSide === 'left' ? 1 : -1);
        const velocityY = initialVerticalBurstSpeed;
        
        const gravity = 0.08;
        const dampingFactor = 0.96;

        const rotation = Math.random() * Math.PI * 2;
        const rotationSpeed = Math.random() * 0.1 - 0.05;
        const opacity = 1;

        return { x: spawnX, y: spawnY, radius, color, 
                 velocityX, velocityY, gravity, dampingFactor,
                 rotation, rotationSpeed, opacity };
    }

    function drawConfetti() {
        if (!confettiCtx) return;
        confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

        for (let i = confettiParticles.length - 1; i >= 0; i--) {
            const p = confettiParticles[i];

            p.velocityX *= p.dampingFactor;
            p.velocityY *= p.dampingFactor;

            p.x += p.velocityX;
            p.y += p.velocityY;
            p.velocityY += p.gravity;
            p.rotation += p.rotationSpeed;
            p.opacity -= 0.005;

            if (p.y > confettiCanvas.height + p.radius || p.x < -p.radius || p.x > confettiCanvas.width + p.radius || p.opacity <= 0) {
                confettiParticles.splice(i, 1); 
            } else {
                confettiCtx.save();
                confettiCtx.translate(p.x, p.y);
                confettiCtx.rotate(p.rotation);
                confettiCtx.globalAlpha = p.opacity;
                confettiCtx.fillStyle = p.color;
                confettiCtx.fillRect(-p.radius, -p.radius, p.radius * 2, p.radius * 2); 
                confettiCtx.restore();
            }
        }
        confettiAnimationId = requestAnimationFrame(drawConfetti);
    }

    function triggerNextConfettiBurstSequence() {
        stopConfettiBursts();
        confettiParticles = [];
        currentBurstIndexInRound = 0;

        performSingleConfettiBurst();
    }

    function performSingleConfettiBurst() {
        if (!confettiCanvas) return;

        const emitterIndex = burstOrderIndices[currentBurstIndexInRound];
        const currentY = confettiCanvas.height * emitterYPositions[emitterIndex];

        for (let i = 0; i < 15; i++) {
            confettiParticles.push(createConfettiParticle(0, currentY, 'left'));
        }
        for (let i = 0; i < 15; i++) {
            confettiParticles.push(createConfettiParticle(confettiCanvas.width, currentY, 'right'));
        }

        currentBurstIndexInRound++;

        if (currentBurstIndexInRound < burstOrderIndices.length) {
            burstSequenceTimerId = setTimeout(performSingleConfettiBurst, burstBetweenPairsDelayMs);
        } else {
            currentBurstIndexInRound = 0;
            burstSequenceTimerId = setTimeout(performSingleConfettiBurst, delayBetweenRoundsMs);
        }
    }


    function stopConfetti() {
        if (confettiAnimationId) {
            cancelAnimationFrame(confettiAnimationId);
            confettiAnimationId = null;
        }
        stopConfettiBursts();
        confettiParticles = [];
        if (confettiCtx) confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        window.removeEventListener('resize', resizeConfettiCanvas);
    }

    function stopConfettiBursts() {
        if (burstSequenceTimerId) {
            clearTimeout(burstSequenceTimerId);
            burstSequenceTimerId = null;
        }
    }

    // --- è¼”åŠ©å‡½æ•¸ ---
    function centerViewOnPlayer(animated = true) { const cellSize=parseInt(getComputedStyle(document.documentElement).getPropertyValue("--cell-size").trim()),cW=gameContainer.clientWidth,cH=gameContainer.clientHeight;const mX=-gameState.playerPos.x*cellSize+cW/2-cellSize/2,mY=-gameState.playerPos.y*cellSize+cH/2-cellSize/2;mazeEl.style.transition=animated?`transform ${gameSession.currentMoveSpeed}ms linear`:"none";mazeEl.style.transform=`translate(${mX}px, ${mY}px)`}
    let visibleCells = new Set();
    function computeFov() { visibleCells.clear(); visibleCells.add(`${gameState.playerPos.x},${gameState.playerPos.y}`); const octants=[{xx:1,xy:0,yx:0,yy:1},{xx:0,xy:1,yx:1,yy:0},{xx:0,xy:-1,yx:1,yy:0},{xx:-1,xy:0,yx:0,yy:1},{xx:-1,xy:0,yx:0,yy:-1},{xx:0,xy:-1,yx:-1,yy:0},{xx:0,xy:1,yx:-1,yy:0},{xx:1,xy:0,yx:0,yy:-1}]; octants.forEach(o => castLight(1,1,0,o.xx,o.xy,o.yx,o.yy)); }
    function castLight(row,start,end,xx,xy,yx,yy){ let newStart=0;if(start<end)return;let r2=FOV_RADIUS*FOV_RADIUS;for(let j=row;j<=FOV_RADIUS;j++){let dx=-j-1,dy=-j,blocked=!1;while(dx<=0){dx++;let mX=gameState.playerPos.x+dx*xx+dy*xy,mY=gameState.playerPos.y+dx*yx+dy*yy;if(mX<0||mX>=gameState.mazeData[0].length||mY<0||mY>=gameState.mazeData.length)continue;let lS=(dx-.5)/(dy+.5),rS=(dx+.5)/(dy-.5);if(start<rS)continue;else if(end>lS)break;if(dx*dx+dy*dy<r2)visibleCells.add(`${mX},${mY}`);let isWall=gameState.mazeData[mY]?.[mX]==="W";if(blocked){if(isWall){newStart=rS;continue}else{blocked=!1;start=newStart}}else{if(isWall&&j<FOV_RADIUS){blocked=!0;castLight(j+1,start,lS,xx,xy,yx,yy);newStart=rS}}}if(blocked)break}}
    function updateFovDisplay() {
        document.querySelectorAll(".grid-cell.visible").forEach(el=>el.classList.remove("visible"));
        visibleCells.forEach(key=>{const cell=document.getElementById(`cell-${key.replace(',','-')}`);if(cell)cell.classList.add("visible")});
        gameState.monsters.forEach(m=>{document.getElementById(`monster-${m.id}`)?.classList.toggle("visible",visibleCells.has(`${m.pos.x},${m.pos.y}`))});
        for (const t of gameState.treasures) {
            const treasureEl = document.getElementById(t.id);
            if (treasureEl) {
                if (!t.found) {
                    treasureEl.classList.toggle("visible", visibleCells.has(`${t.pos.x},${t.pos.y}`));
                } else {
                    treasureEl.classList.add("visible");
                }
            }
        }
        for (const d of gameState.activeDarts) {
            const dartEl = document.getElementById(d.id);
            if (dartEl) {
                dartEl.classList.add("visible"); 
            }
        }
    }
    function canMove(pos,dir){let newPos={...pos};if(dir==="up")newPos.y--;else if(dir==="down")newPos.y++;else if(dir==="left")newPos.x--;else if(dir==="right")newPos.x++;return gameState.mazeData[newPos.y]?.[newPos.x]&&gameState.mazeData[newPos.y][newPos.x]!=="W"}
    function getDistance(p1,p2){return Math.sqrt(Math.pow(p1.x-p2.x,2)+Math.pow(p1.y-p2.y,2))}
    function findPath(start,end){const q=[[start]],visited=new Set([`${start.x},${start.y}`]),dirs=["up","down","left","right"];while(q.length>0){const path=q.shift(),pos=path[path.length-1];if(pos.x===end.x&&pos.y===end.y)return path;for(const dir of dirs){let next={...pos};if(dir==="up")next.y--;else if(dir==="down")next.y++;else if(dir==="left")next.x--;else if(dir==="right")next.x++;const key=`${next.x},${next.y}`;if(!visited.has(key)&&canMove(pos,dir)){visited.add(key);q.push([...path,next])}}}return null}
    function isPlayerVisible(monsterPos,playerPos){if(getDistance(monsterPos,playerPos)>FOV_RADIUS)return!1;let x0=monsterPos.x,y0=monsterPos.y;const x1=playerPos.x,y1=playerPos.y;const dx=Math.abs(x1-x0),sx=x0<x1?1:-1;const dy=-Math.abs(y1-y0),sy=y0<y1?1:-1;let err=dx+dy,e2;while(!0){if(gameState.mazeData[y0]?.[x0]==="W")return!1;if(x0===x1&&y0===y1)break;e2=2*err;if(e2>=dy){err+=dy;x0+=sx}if(e2<=dx){err+=dx;y0+=sy}}return!0}
    
    // Keyboard Input Handling (for both movement and actions)
    const MOVE_KEY_MAP = {
        ArrowUp: "up", w: "up",
        ArrowDown: "down", s: "down",
        ArrowLeft: "left", a: "left",
        ArrowRight: "right", d: "right"
    };

    function handleKeyDown(e){ 
        if (gameSession.isPaused) return; 

        if (e.code === 'Space' || e.key === ' ') { 
            e.preventDefault(); 
            placeBomb(); 
            return;
        }
        if (e.key === 'f' || e.key === 'F' || e.key === 'é›¢') { 
            e.preventDefault();
            shootDart();
            return;
        }

        const direction = MOVE_KEY_MAP[e.key];
        if (direction) {
            playerMovement.activeKeyboardDirections.add(direction);
            e.preventDefault();
        }
    }

    function handleKeyUp(e){ 
        if (gameSession.isPaused) return; 

        const direction = MOVE_KEY_MAP[e.key];
        if (direction) {
            playerMovement.activeKeyboardDirections.delete(direction);
        }
    }

    // Joystick Input Handling
    let isJoystickDragging=!1,joystickOrigin={x:0,y:0},maxJoystickRadius=0;
    function joystickTouchStart(e){
        if (e.target === joystickHandle || e.target === joystickContainer) {
            e.preventDefault(); 
        }
        isJoystickDragging=!0;
        const r=joystickContainer.getBoundingClientRect();
        joystickOrigin={x:r.left+r.width/2,y:r.top+r.height/2};
        maxJoystickRadius=joystickContainer.offsetWidth/2-joystickHandle.offsetWidth/2;
        joystickTouchMove(e);
    }
    function joystickTouchMove(e){
        if(!isJoystickDragging)return;
        if (e.target === joystickHandle || e.target === joystickContainer) {
            e.preventDefault(); 
        }
        
        const t=e.touches[0];
        let dx=t.clientX-joystickOrigin.x,dy=t.clientY-joystickOrigin.y;
        const dist=Math.sqrt(dx*dx+dy*dy);
        if(dist>maxJoystickRadius){dx=dx/dist*maxJoystickRadius;dy=dy/dist*maxJoystickRadius}
        joystickHandle.style.transform=`translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
        
        let d = null;
        if(dist < 20) {
            d = null;
        } else if(Math.abs(dx) > Math.abs(dy)){
            d = dx > 0 ? "right" : "left";
        } else {
            d = dy > 0 ? "down" : "up";
        }
        playerMovement.joystickDirection = d;
    }
    function joystickTouchEnd(e){
        if(!isJoystickDragging)return;
        if (e.target === joystickHandle || e.target === joystickContainer) {
             e.preventDefault();
        }
        isJoystickDragging=!1;
        joystickHandle.style.transform="translate(-50%, -50%)";
        playerMovement.joystickDirection = null;
    }
    
    // Control UI elements visibility and attach/detach event listeners
    const handlePlaceBombTouch = (e) => { e.preventDefault(); placeBomb(); };
    const handleShootDartTouch = (e) => { e.preventDefault(); shootDart(); };

    function setupGameUIForDevice() {
        if (isTouchDevice) {
            joystickContainer.style.display = 'block';
            joystickContainer.addEventListener("touchstart", joystickTouchStart, { passive: false }); 
            document.addEventListener("touchmove", joystickTouchMove, { passive: false }); 
            document.addEventListener("touchend", joystickTouchEnd, { passive: false }); 
            document.addEventListener("touchcancel", joystickTouchEnd, { passive: false }); 

            placeBombBtn.addEventListener("touchstart", handlePlaceBombTouch, { passive: false });
            shootDartBtn.addEventListener("touchstart", handleShootDartTouch, { passive: false });
            placeBombBtn.style.display = 'flex'; 
            shootDartBtn.style.display = 'flex';
        } else {
            joystickContainer.style.display = 'none';
            placeBombBtn.style.display = 'flex'; 
            shootDartBtn.style.display = 'flex';
        }
    }

    function removeGameUIListeners() {
        joystickContainer.removeEventListener("touchstart", joystickTouchStart); 
        document.removeEventListener("touchmove", joystickTouchMove); 
        document.removeEventListener("touchend", joystickTouchEnd); 
        document.removeEventListener("touchcancel", joystickTouchEnd); 

        placeBombBtn.removeEventListener("touchstart", handlePlaceBombTouch);
        shootDartBtn.removeEventListener("touchstart", handleShootDartTouch);
    }

    function removeGameUIElementsDisplay() {
        joystickContainer.style.display = 'none';
        placeBombBtn.style.display = 'none';
        shootDartBtn.style.display = 'none';
    }


    function clearGameListeners() { 
        if(playerMovement.moveInterval) clearInterval(playerMovement.moveInterval); 
        playerMovement.moveInterval = null; 
        document.removeEventListener("keydown", handleKeyDown); 
        document.removeEventListener("keyup", handleKeyUp); 
        removeGameUIListeners();
        removeGameUIElementsDisplay();
        gameState.activeDarts.forEach(dart => {
            clearInterval(dart.intervalId);
            if (dart.element) dart.element.remove();
        });
        gameState.activeDarts = [];
    }

    // --- äº‹ä»¶ç›£è½å™¨èˆ‡åˆå§‹åŒ– ---
    document.getElementById('start-game-btn').addEventListener('click', () => {
        setupGameUIForDevice();
        startGame(true);
    });
    document.getElementById('retry-btn').addEventListener('click', () => { 
        setupGameUIForDevice();
        clearGameListeners();
        startGame(false);
    });
    document.getElementById('back-to-menu-btn').addEventListener('click', () => { 
        removeGameUIListeners();
        removeGameUIElementsDisplay();
        clearGameListeners();
        showScreen('start'); 
    });
    
    document.getElementById('back-to-menu-from-win-btn').addEventListener('click', () => { 
        removeGameUIListeners();
        removeGameUIElementsDisplay();
        clearGameListeners();
        stopConfetti();
        showScreen('start'); 
    });

    placeBombBtn.addEventListener('click', placeBomb);
    shootDartBtn.addEventListener('click', shootDart);
    notificationCloseBtn.addEventListener('click', hideNotification);

    isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    showScreen('start');
});
</script>
</body>
</html>