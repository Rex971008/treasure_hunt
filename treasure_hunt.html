<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çˆ¶è¦ªç¯€å¤§å†’éšªï¼</title>
    <style>
        :root {
            --wall-color: #2c3e50; --path-color: #ecf0f1; --start-color: #3498db;
            --treasure-color: #f1c40f; --player-size: 28px; --cell-size: 40px;
            --primary-bg: #34495e; --text-color: #ffffff; --button-bg: #2ecc71;
            --button-hover-bg: #27ae60; --danger-bg: #e74c3c; --dark-color: #1a2531;
            --visible-transition: background-color 0.4s ease, opacity 0.4s ease;
        }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; font-family: 'Microsoft JhengHei', 'å¾®è»Ÿæ­£é»‘é«”', sans-serif; background-color: var(--primary-bg); color: var(--text-color); overflow: hidden; -webkit-user-select: none; user-select: none; }
        .screen { display: none; width: 100%; height: 100%; flex-direction: column; justify-content: center; align-items: center; text-align: center; box-sizing: border-box; padding: 20px; animation: fadeIn 0.5s ease-in-out; position: relative; }
        .screen.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        h1 { font-size: 3em; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        h2 { font-size: 2em; margin-bottom: 30px; }
        p { font-size: 1.2em; margin-top: 20px; line-height: 1.6; }
        .button { background-color: var(--button-bg); color: white; padding: 15px 30px; border: none; border-radius: 8px; font-size: 1.2em; cursor: pointer; margin: 10px; transition: all 0.3s ease; box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
        .button.danger { background-color: var(--danger-bg); }
        .button.danger:hover { background-color: #c0392b; }
        .button:hover:not(:disabled) { background-color: var(--button-hover-bg); transform: translateY(-2px); }
        .button:active:not(:disabled) { transform: translateY(1px); }
        #game-container { width: 100vw; height: 100vh; border: none; background-color: var(--dark-color); position: relative; overflow: hidden; }
        
        /* å…¨æ–°çš„é ‚éƒ¨ UI å®¹å™¨ */
        #top-ui-bar {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px; /* å»¶ä¼¸åˆ°æ•´å€‹å¯¬åº¦ */
            display: flex;
            justify-content: space-between; /* å·¦å³å…©ç«¯å°é½Š */
            align-items: center;
            gap: 15px; /* å…§éƒ¨å…ƒç´ é–“è· */
            z-index: 20; /* ç¢ºä¿åœ¨æœ€ä¸Šå±¤ */
            pointer-events: none; /* é è¨­ä¸é˜»æ“‹ä¸‹æ–¹é»æ“Š */
        }
        #top-ui-bar > div, #top-ui-bar > button { /* è®“ UI å…ƒç´ å¯ä»¥è¢«é»æ“Š/äº’å‹• */
            pointer-events: auto;
        }

        #bomb-counter, #dart-counter { 
            background-color: rgba(0,0,0,0.5); padding: 8px 15px; border-radius: 8px; font-size: 1.5em; display: flex; align-items: center; gap: 8px; 
        }
        #bomb-count-text, #dart-count-text { font-weight: bold; }

        /* é¡¯ç¤ºæ‰¾åˆ°çš„å­—æ¨£ (ç¾åœ¨åœ¨ #top-ui-bar å…§ï¼Œä¸å†æ˜¯çµ•å°å®šä½) */
        #found-chars-display {
            background-color: rgba(0,0,0,0.5);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--treasure-color);
            font-weight: bold;
            /* é€™äº›å±¬æ€§æœƒè¢« flexbox çˆ¶å…ƒç´ ç®¡ç† */
            /* position: absolute; top: 15px; left: 15px; */ 
        }
        #found-chars-display span {
            min-width: 1em; /* ç¢ºä¿å­—ç¬¦æœ‰è¶³å¤ çš„ç©ºé–“ */
            text-align: center;
            display: inline-block;
        }

        #place-bomb-btn, #shoot-dart-btn { /* Combined styles for both action buttons */
            position: absolute;
            width: 70px; height: 70px;
            border-radius: 50%;
            font-size: 2.5em; padding: 0;
            z-index: 100;
            background-color: rgba(52, 73, 94, 0.7);
            display: flex; /* Always display for desktop, controlled for touch by JS */
            justify-content: center; align-items: center;
        }
        #place-bomb-btn { bottom: 40px; right: 40px; }
        #shoot-dart-btn { bottom: 120px; right: 40px; } /* Positioned above bomb button */

        #place-bomb-btn:hover:not(:disabled),
        #shoot-dart-btn:hover:not(:disabled) { background-color: rgba(44, 62, 80, 1); }

        #maze { position: absolute; display: grid; }
        #player { width: var(--player-size); height: var(--player-size); background-size: cover; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .monster { width: var(--player-size); height: var(--player-size); background-size: cover; border-radius: 8px; position: absolute; z-index: 9; transition: transform 0.1s linear, filter 0.5s ease, opacity 0.5s ease; opacity: 0; }
        .monster.visible { opacity: 1; }
        
        /* çµ±ä¸€ä¸­å¿ƒå®šä½ï¼ŒJS åªè² è²¬è¨­å®š left/top */
        .bomb, .explosion, .dart, .treasure {
            position: absolute;
            width: var(--cell-size);
            height: var(--cell-size);
            display: flex;
            justify-content: center;
            align-items: center;
            transform: translate(-50%, -50%); /* ä¿æŒå…ƒç´ ä¸­å¿ƒåœ¨æ ¼å­ä¸­å¿ƒ */
            box-sizing: border-box; /* ç¢ºä¿ padding/border ä¸æœƒæ’å¤§å…ƒç´  */
        }
        .bomb { font-size: 28px; opacity: 0.9; z-index: 7; }
        /* çˆ†ç‚¸ç‰¹æ•ˆæ¨£å¼ */
        .explosion { font-size: 36px; z-index: 50; pointer-events: none; animation: explosion-anim 0.5s ease-out forwards; }
        @keyframes explosion-anim { from { transform: scale(0.5); opacity: 1; } to { transform: scale(2); opacity: 0; } }

        /* é£›é¢æ¨£å¼ */
        .dart {
            font-size: 2em; /* Dart emoji size */
            z-index: 12; /* Above player/monsters */
            transition: none; /* Dart should not animate with transform */
        }
        
        /* å¯¶è—å…ƒç´ æ¨£å¼ */
        .treasure {
            width: var(--player-size);
            height: var(--player-size);
            z-index: 8;
            opacity: 0; /* Initially hidden, becomes visible with FOV */
            background-color: var(--treasure-color); /* Add a background */
            border-radius: 50%; /* Make it round */
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            color: var(--primary-bg); /* Text color contrasting with background */
            font-weight: bold;
        }
        .treasure.visible {
            opacity: 1;
            transition: var(--visible-transition);
        }
        /* å·²æ‰¾åˆ°çš„å¯¶è—ï¼Œé€æ˜åº¦é™ä½ */
        .treasure.found-item {
            opacity: 0.5;
            transition: opacity 0.5s ease;
        }

        .grid-cell { width: var(--cell-size); height: var(--cell-size); transition: var(--visible-transition); }
        .wall { background-color: var(--wall-color); opacity: 0.5; }
        .path, .start, .treasure-location { background-color: var(--dark-color); }
        .grid-cell.visible:not(.wall) { background-color: var(--path-color); }
        .grid-cell.start.visible { background-color: var(--start-color); }
        .grid-cell.treasure-location.visible { background-color: var(--treasure-color); }
        
        /* å‹åˆ©ç•«é¢ä½ˆå±€ */
        #win-screen {
            position: relative;
            /* Ensure children are positioned correctly */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Hide confetti overflow */
        }
        #riddle-box {
            background: rgba(0,0,0,0.7); /* Make background darker for contrast */
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            position: relative; /* Ensure it's above canvas */
            z-index: 1;
        } 

        #joystick-container { position: absolute; bottom: 40px; left: 40px; width: 150px; height: 150px; display: none; z-index: 100; user-select: none; -webkit-user-select: none; }
        #joystick-base { position: relative; width: 100%; height: 100%; background-color: rgba(52, 73, 94, 0.5); border-radius: 50%; border: 3px solid rgba(236, 240, 241, 0.5); }
        #joystick-handle { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background-color: rgba(52, 152, 219, 0.8); border-radius: 50%; transform: translate(-50%, -50%); transition: transform 0.1s ease-out; }
        .notification-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); display: none; justify-content: center; align-items: center; z-index: 1000; animation: fadeIn 0.3s ease; }
        .notification-overlay.active { display: flex; }
        .notification-box { background: var(--primary-bg); padding: 20px 30px; border-radius: 15px; text-align: center; max-width: 90%; width: 450px; border: 2px solid var(--button-bg); box-shadow: 0 5px 15px rgba(0,0,0,0.5); transform: scale(0.9); opacity: 0; transition: transform 0.3s ease-out, opacity 0.3s ease-out; }
        .notification-overlay.active .notification-box { transform: scale(1); opacity: 1; }
        .notification-box p { font-size: 1.3em; margin-bottom: 25px; color: var(--text-color); }
        
        /* å½©å¸¶canvas */
        #confetti-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* Behind riddle-box */
            pointer-events: none; /* Allow clicks on buttons beneath */
        }

        /* éŠæˆ²çµæŸç•«é¢å½±ç‰‡èƒŒæ™¯ */
        #game-over-screen {
            position: relative; /* Ensure content is positioned relative to this */
            display: none; /* Initially hidden */
        }
        #game-over-screen.active {
            display: flex;
        }
        #game-over-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* ç¢ºä¿å½±ç‰‡è¦†è“‹æ•´å€‹å€åŸŸï¼Œä¸è®Šå½¢ */
            z-index: -1; /* æ”¾ç½®åœ¨å…§å®¹ä¹‹å¾Œ */
        }
        /* ç¢ºä¿çµæŸç•«é¢çš„æ–‡å­—å’ŒæŒ‰éˆ•åœ¨å½±ç‰‡ä¹‹ä¸Šä¸”å¯è®€ */
        #game-over-screen h1,
        #game-over-screen p,
        #game-over-screen .button {
            position: relative; /* å°‡é€™äº›å…ƒç´ æå‡åˆ°å½±ç‰‡ä¸Šæ–¹ */
            z-index: 1;
            background: rgba(0,0,0,0.6); /* çµ¦å…§å®¹ä¸€å€‹åŠé€æ˜èƒŒæ™¯ä»¥æé«˜å¯è®€æ€§ */
            padding: 15px 30px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="start-screen" class="screen active"><h1>çˆ¶è¦ªç¯€å¤§å†’éšª</h1><h2>è¦ªæ„›çš„çˆ¸çˆ¸ï¼Œçˆ¶è¦ªç¯€å¿«æ¨‚ï¼</h2><p>åœ¨è¿·å®®æ·±è™•ï¼Œè—è‘—ä¸€ä»½çµ¦ä½ çš„çˆ¶è¦ªç¯€é©šå–œ...<br>è«‹å‹‡æ•¢åœ°å»å°‹æ‰¾å®ƒå§ï¼</p><button id="start-game-btn" class="button">é–‹å§‹å†’éšªï¼</button></div>
    <div id="game-screen" class="screen">
        <div id="game-container">
            <div id="maze"></div>
            <div id="player"></div>
            <!-- å…¨æ–°çš„é ‚éƒ¨ UI å®¹å™¨ï¼Œæ•´åˆäº†æ‰€æœ‰è¨ˆæ•¸å™¨å’Œæ–‡å­—é¡¯ç¤º -->
            <div id="top-ui-bar">
                <div id="found-chars-display">
                    <span id="char-0">_</span><span id="char-1">_</span><span id="char-2">_</span>
                </div>
                <!-- å°‡ç‚¸å½ˆå’Œé£›é¢è¨ˆæ•¸å™¨åŒ…è£åœ¨ä¸€å€‹ div ä¸­ï¼Œä»¥ä¾¿åœ¨ flex å®¹å™¨ä¸­çµ±ä¸€å³å°é½Š -->
                <div style="display: flex; gap: 15px;">
                    <div id="bomb-counter">ğŸ’£<span id="bomb-count-text">10</span></div>
                    <div id="dart-counter">ğŸªƒ<span id="dart-count-text">5</span></div>
                </div>
                <!-- åŸæœ‰çš„ 'æ”¾æ£„æŒ‘æˆ°' æŒ‰éˆ•å·²ç§»é™¤ -->
            </div>

            <div id="joystick-container"><div id="joystick-base"><div id="joystick-handle"></div></div></div>
            <button id="place-bomb-btn" class="button">ğŸ’£</button>
            <button id="shoot-dart-btn" class="button">ğŸªƒ</button> <!-- æ–°å¢é£›é¢æŒ‰éˆ• -->
        </div>
    </div>
    <div id="win-screen" class="screen">
        <canvas id="confetti-canvas"></canvas> <!-- æ–°å¢ï¼šå½©å¸¶canvas -->
        <div id="riddle-box">
            <h1>æ­å–œï¼ä½ æ‰¾åˆ°äº†å…¨éƒ¨ç¦®ç‰©ï¼</h1>
            <p>è¦ªæ„›çš„çˆ¸çˆ¸ï¼Œç¥æ‚¨çˆ¶è¦ªç¯€å¿«æ¨‚ï¼</p>
            <p style="color: var(--treasure-color); font-weight: bold; font-size: 1.4em;">
                æ„Ÿè¬æ‚¨ä¸€ç›´ä»¥ä¾†ç‚ºå®¶åº­å¸¶ä¾†çš„<br>
                æº«æš–ã€å®‰å…¨èˆ‡æ™ºæ…§ï¼<br>
                ç¥æ‚¨å¥åº·å¹³å®‰ã€äº‹äº‹é †å¿ƒï¼
            </p>
            <button id="back-to-menu-from-win-btn" class="button">å›åˆ°é–‹å§‹ç•«é¢</button>
        </div>
    </div>
    <div id="game-over-screen" class="screen">
        <video id="game-over-video" autoplay loop muted playsinline>
            <source src="images/gameover_bg.mp4" type="video/mp4">
            <!-- æ‚¨å¯ä»¥æ·»åŠ å…¶ä»–å½±ç‰‡æ ¼å¼ä»¥æé«˜å…¼å®¹æ€§ï¼Œä¾‹å¦‚ï¼š -->
            <!-- <source src="images/gameover_bg.webm" type="video/webm"> -->
            æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æŒå½±ç‰‡æ’­æ”¾ã€‚
        </video>
        <h1>å“å‘€ï¼è¢«æŠ“åˆ°äº†ï¼</h1>
        <p>åˆ¥ç°å¿ƒï¼Œå†’éšªç¸½æ˜¯å……æ»¿æŒ‘æˆ°ï¼Œæ­£å¦‚äººç”Ÿä¸€èˆ¬ã€‚</p>
        <button id="retry-btn" class="button">æ²’å•é¡Œï¼Œæ€éº¼å¯èƒ½æœƒæ”¾æ£„ï¼</button><button id="back-to-menu-btn" class="button">å›åˆ°é–‹å§‹ç•«é¢</button></div>
    <div id="notification-overlay" class="notification-overlay"><div id="notification-box"><p id="notification-text"></p><button id="notification-close-btn" class="button">äº†è§£ï¼</button></div></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- è®Šæ•¸å®£å‘Šå€ ---
    const screens = { start: document.getElementById('start-screen'), game: document.getElementById('game-screen'), win: document.getElementById('win-screen'), gameOver: document.getElementById('game-over-screen') };
    const mazeEl = document.getElementById("maze"), playerEl = document.getElementById("player"), gameContainer = document.getElementById("game-container"), joystickContainer = document.getElementById("joystick-container"), joystickHandle = document.getElementById("joystick-handle");
    const bombCountTextSpan = document.getElementById("bomb-count-text"), placeBombBtn = document.getElementById("place-bomb-btn"); // Changed to access span directly
    const dartCountTextSpan = document.getElementById("dart-count-text"), shootDartBtn = document.getElementById("shoot-dart-btn"); // Changed to access span directly
    const notificationOverlay = document.getElementById("notification-overlay"), notificationText = document.getElementById("notification-text"), notificationCloseBtn = document.getElementById("notification-close-btn");
    const gameOverVideo = document.getElementById("game-over-video"); // éŠæˆ²çµæŸå½±ç‰‡å…ƒç´ 
    
    // æ‰¾åˆ°çš„å­—æ¨£ UI å…ƒç´  (ç¾åœ¨åœ¨ #top-ui-bar å…§)
    const foundCharsDisplay = document.getElementById("found-chars-display");
    const charSpans = [
        document.getElementById("char-0"),
        document.getElementById("char-1"),
        document.getElementById("char-2")
    ];

    // --- éŠæˆ²ç‹€æ…‹èˆ‡è¨­å®š ---
    const TREASURE_CHARS = ["å®‰", "å…¨", "å¸½"]; // å®šç¾©è¦æ‰¾çš„å­—
    // æŒä¹…åŒ–ç‹€æ…‹ï¼šè¨˜éŒ„å“ªäº›å­—å·²ç¶“è¢«æ‰¾åˆ°äº†ã€‚åªæœ‰å¾é–‹å§‹ç•«é¢é‡æ–°é–‹å§‹æ‰æœƒé‡ç½®ã€‚
    let foundCharactersPersistent = new Array(TREASURE_CHARS.length).fill(false);

    let gameState = {
        mazeData: [],
        playerPos: { x: 0, y: 0 },
        treasures: [], // å¯¶è—é™£åˆ—: [{pos: {x,y}, char: 'å®‰', found: false, id: 'treasure-å®‰'}, ...]
        monsters: [],
        bombsRemaining: 0,
        placedBombs: [],
        dartsRemaining: 0, // æ–°å¢é£›é¢æ•¸é‡
        activeDarts: [], // è¿½è¹¤é£›è¡Œä¸­çš„é£›é¢
        foundTreasuresCount: 0, // ç•¶å‰éŠæˆ²å›åˆä¸­æ‰¾åˆ°çš„å¯¶è—æ•¸é‡
        foundChars: ['', '', ''], // ç•¶å‰éŠæˆ²å›åˆä¸­æ‰¾åˆ°çš„å­—æ¨£ï¼Œç”¨æ–¼é¡¯ç¤º
        playerLastDirection: 'right', // è¨˜éŒ„ç©å®¶æœ€å¾Œä¸€æ¬¡ç§»å‹•çš„æ–¹å‘ï¼Œç”¨æ–¼ç™¼å°„é£›é¢
    };
    let gameSession = { currentMoveSpeed: 120, isPaused: false };
    
    // --- é‡æ§‹å¾Œçš„ç©å®¶ç§»å‹•ç‹€æ…‹ ---
    let playerMovement = {
        activeKeyboardDirections: new Set(), // å„²å­˜æ‰€æœ‰ç›®å‰æŒ‰ä¸‹çš„ç§»å‹•éµ (ä¾‹å¦‚ 'up', 'left')
        joystickDirection: null,             // å„²å­˜æ–æ¡¿ç•¶å‰æä¾›çš„æ–¹å‘
        currentExecutingDirection: null,     // ç©å®¶å¯¦éš›æ­£åœ¨åŸ·è¡Œä¸¦ç§»å‹•çš„æ–¹å‘
        nextDesiredDirection: null,          // ç©å®¶æœŸæœ›çš„ä¸‹ä¸€å€‹æ–¹å‘ (ç”¨æ–¼å¹³æ»‘åˆ‡æ›)
        moveInterval: null,
        lastPos: { x: -1, y: -1 }
    };
    
    const levelConfig = { w: 15, h: 10, m: 5, initialBombs: 10, initialDarts: 5 }; // æ–°å¢åˆå§‹é£›é¢æ•¸é‡
    const FOV_RADIUS = 10;
    // æ€ªç‰©é€Ÿåº¦æ¸›æ…¢ (å€¼è¶Šå¤§è¶Šæ…¢)
    const MONSTER_TIERS = [ 
        {level:1,colorFilter:"hue-rotate(0deg) saturate(0.8)",speed:1500}, // æ›´æ…¢
        {level:2,colorFilter:"hue-rotate(90deg) saturate(1.2)",speed:1200}, 
        {level:3,colorFilter:"hue-rotate(200deg) saturate(1.5)",speed:900} 
    ];
    let isTouchDevice = false;

    // å½©å¸¶ç‰¹æ•ˆç›¸é—œè®Šæ•¸
    let confettiCanvas, confettiCtx, confettiParticles = [], confettiAnimationId;
    let burstSequenceTimerId; // ç”¨æ–¼æ§åˆ¶åºåˆ—åŒ–å™´ç™¼çš„å®šæ™‚å™¨ ID

    // å®šç¾©å…­å€‹ç™¼å°„é»çš„ Y è»¸æ¯”ä¾‹ (å¾ä¸Šåˆ°ä¸‹: 5&6, 3&4, 1&2 çš„è¦–è¦ºä½ç½®)
    // æ•¸å­—è¶Šå°è¶Šé è¿‘é ‚éƒ¨ï¼Œæ•¸å­—è¶Šå¤§è¶Šé è¿‘åº•éƒ¨
    const emitterYPositions = [0.2, 0.5, 0.8]; 

    // å®šç¾©å™´ç™¼çš„é †åºï¼Œå¾ä¸‹å¾€ä¸Š (1&2 -> 3&4 -> 5&6)
    // å°æ‡‰ emitterYPositions çš„ç´¢å¼•: 2 (åº•éƒ¨), 1 (ä¸­é–“), 0 (é ‚éƒ¨)
    const burstOrderIndices = [2, 1, 0]; 
    let currentBurstIndexInRound = 0; // ç•¶å‰åœ¨é€™ä¸€è¼ªä¸­çš„å™´ç™¼ç´¢å¼• (0, 1, 2)

    const burstBetweenPairsDelayMs = 200; // åŒä¸€è¼ªä¸­ï¼Œæ¯å°ç™¼å°„é»ä¹‹é–“çš„å»¶é² (ä¾‹å¦‚ 1&2 å™´ç™¼å¾Œï¼Œ200ms å† 3&4)
    const delayBetweenRoundsMs = 2000;   // æ¯è¼ªå™´ç™¼å®Œæˆå¾Œï¼Œèˆ‡ä¸‹ä¸€è¼ªé–‹å§‹çš„å»¶é² (2ç§’)


    // --- æ ¸å¿ƒåŠŸèƒ½ ---
    function showScreen(screenName) { 
        Object.values(screens).forEach(s => s.classList.remove('active')); 
        if(screens[screenName]) {
            screens[screenName].classList.add('active');
            // è™•ç†éŠæˆ²çµæŸå½±ç‰‡æ’­æ”¾
            if (screenName === 'gameOver' && gameOverVideo) {
                gameOverVideo.play();
            } else if (gameOverVideo) {
                gameOverVideo.pause();
                gameOverVideo.currentTime = 0; // é‡ç½®å½±ç‰‡åˆ°é–‹é ­
            }
        }
    }
    function seededRandom(seed) { let state = seed % 2147483647; if (state <= 0) state += 2147483646; return function() { state = state * 16807 % 2147483647; return (state - 1) / 2147483646; } }

    // --- éŠæˆ²ä¸»å¾ªç’° ---
    function mainGameLoop() {
        if (gameSession.isPaused) return;

        // 1. æ ¹æ“šè¼¸å…¥æ›´æ–°ç©å®¶çš„ç§»å‹•æ„åœ–
        updatePlayerMovementIntents();

        let finalMoveDirection = null;

        // --- å¹³æ»‘ç§»å‹•é‚è¼¯ ---
        // Step 1: Check if the 'next desired' direction is immediately executable
        if (playerMovement.nextDesiredDirection && canMove(gameState.playerPos, playerMovement.nextDesiredDirection)) {
            finalMoveDirection = playerMovement.nextDesiredDirection;
            playerMovement.currentExecutingDirection = finalMoveDirection; // Adopt the new direction
            playerMovement.nextDesiredDirection = null; // Clear the queued direction
        }
        // Step 2: If not, try to continue with the 'current executing' direction
        else if (playerMovement.currentExecutingDirection && canMove(gameState.playerPos, playerMovement.currentExecutingDirection)) {
            finalMoveDirection = playerMovement.currentExecutingDirection;
            // No change to currentExecutingDirection, it continues
            // nextDesiredDirection (if any) remains queued if it couldn't be executed
        } else {
            // No valid direction to move in (either blocked or no input)
            playerMovement.currentExecutingDirection = null; // Stop execution
            playerMovement.nextDesiredDirection = null; // Clear any queued
        }
        // --- End Smooth Movement Logic ---

        if (finalMoveDirection) {
            let newPos = { ...gameState.playerPos };
            if (finalMoveDirection === 'up') newPos.y--; else if (finalMoveDirection === 'down') newPos.y++; else if (finalMoveDirection === 'left') newPos.x--; else if (finalMoveDirection === 'right') newPos.x++;
            gameState.playerPos = newPos;
            centerViewOnPlayer(true);
            gameState.playerLastDirection = finalMoveDirection; // è¨˜éŒ„å¯¦éš›æˆåŠŸç§»å‹•çš„æ–¹å‘
        }
        
        // è¦–é‡æ›´æ–°åŠä¸Šæ¬¡ç§»å‹•æ–¹å‘è¨˜éŒ„ (åªæœ‰ç•¶ç©å®¶ä½ç½®æ”¹è®Šæ™‚æ‰æ›´æ–°)
        if (playerMovement.lastPos.x !== gameState.playerPos.x || playerMovement.lastPos.y !== gameState.playerPos.y) {
            computeFov();
            updateFovDisplay();
            playerMovement.lastPos = {...gameState.playerPos};
        }
        
        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size').trim());
        // æ€ªç‰©ç§»å‹•é‚è¼¯
        for (const monster of gameState.monsters) { 
            // å¦‚æœæ€ªç‰©åœ¨è¦–é‡å¤–ï¼Œä¸”æ²’æœ‰ä¸Šæ¬¡å·²çŸ¥ä½ç½®ï¼Œå‰‡åœæ­¢è¿½é€ï¼Œè®“å®ƒè¿”å›ç”Ÿæˆé»
            if (!visibleCells.has(`${monster.pos.x},${monster.pos.y}`) && monster.state === "CHASING" && !monster.lastKnownPlayerPos) {
                 monster.state = "RETURNING"; 
            }

            monster.moveCooldown += gameSession.currentMoveSpeed;
            if (monster.moveCooldown >= monster.speed) { 
                updateSingleMonsterAI(monster);
                const monsterEl = document.getElementById(`monster-${monster.id}`);
                if (monsterEl) monsterEl.style.transform = `translate(${monster.pos.x * cellSize}px, ${monster.pos.y * cellSize}px)`;
                monster.moveCooldown = 0; 
            }
        }
        
        checkBombCollisions();
        checkPlayerPosition(); // é€™æœƒæª¢æŸ¥å¯¶è—å’Œæ€ªç‰©ç¢°æ’
    }

    // --- æ–°å¢ï¼šæ ¹æ“šæ‰€æœ‰è¼¸å…¥æ›´æ–°ç©å®¶ç§»å‹•æ„åœ–çš„ç‹€æ…‹æ©Ÿ ---
    function updatePlayerMovementIntents() {
        let highestPriorityInputDirection = null;
        const priorityOrder = ['up', 'down', 'left', 'right']; // éµç›¤æ–¹å‘çš„å„ªå…ˆé †åº

        // å„ªå…ˆè€ƒæ…®æ–æ¡¿è¼¸å…¥
        if (playerMovement.joystickDirection) {
            highestPriorityInputDirection = playerMovement.joystickDirection;
        } else {
            // è™•ç†éµç›¤è¼¸å…¥ï¼Œæ ¹æ“šå„ªå…ˆé †åºé¸æ“‡ä¸€å€‹æ–¹å‘
            for (const dir of priorityOrder) {
                if (playerMovement.activeKeyboardDirections.has(dir)) {
                    highestPriorityInputDirection = dir;
                    break;
                }
            }
        }

        // --- æ›´æ–° playerMovement ç‹€æ…‹è®Šæ•¸ ---
        if (highestPriorityInputDirection === null) {
            // å¦‚æœæ²’æœ‰ä»»ä½•ç§»å‹•è¼¸å…¥ï¼Œå‰‡ä¸å†æœ‰æ–°çš„ã€ŒæœŸæœ›æ–¹å‘ã€
            playerMovement.nextDesiredDirection = null;
            // currentExecutingDirection å°‡åœ¨ mainGameLoop ä¸­åˆ¤æ–·æ˜¯å¦ç¹¼çºŒæˆ–åœæ­¢
        } else if (playerMovement.currentExecutingDirection === null) {
            // å¦‚æœç›®å‰æ²’æœ‰åœ¨ç§»å‹•ï¼Œå‰‡å°‡æœ€é«˜å„ªå…ˆç´šçš„è¼¸å…¥æ–¹å‘è¨­ç‚ºç•¶å‰åŸ·è¡Œæ–¹å‘
            playerMovement.currentExecutingDirection = highestPriorityInputDirection;
            playerMovement.nextDesiredDirection = null;
        } else if (highestPriorityInputDirection !== playerMovement.currentExecutingDirection) {
            // å¦‚æœæœ€é«˜å„ªå…ˆç´šçš„è¼¸å…¥æ–¹å‘èˆ‡ç•¶å‰åŸ·è¡Œæ–¹å‘ä¸åŒï¼Œå‰‡å°‡å…¶è¨­ç‚ºä¸‹ä¸€å€‹æœŸæœ›æ–¹å‘ï¼ˆç”¨æ–¼è½‰å½ç·©è¡ï¼‰
            playerMovement.nextDesiredDirection = highestPriorityInputDirection;
        } else {
            // å¦‚æœæ–°çš„æœŸæœ›æ–¹å‘èˆ‡ç•¶å‰æ–¹å‘ç›¸åŒï¼Œä¸”æ²’æœ‰ç­‰å¾…çš„ nextDesiredDirectionï¼Œå‰‡æ¸…ç©º nextDesiredDirection
            playerMovement.nextDesiredDirection = null;
        }
    }
    
    function pauseGame() { gameSession.isPaused = true; }
    function resumeGame() { gameSession.isPaused = false; }

    // --- æ€ªç‰© AI ---
    function updateSingleMonsterAI(monster) {
        const playerVisible = isPlayerVisible(monster.pos, gameState.playerPos);
        switch (monster.state) {
            case "IDLE": 
                if(playerVisible) monster.state="CHASING"; 
                break;
            case "CHASING": 
                if(playerVisible) { monster.lastKnownPlayerPos={...gameState.playerPos} } 
                else { monster.state="SEARCHING" } 
                break;
            case "SEARCHING": 
                if(playerVisible) { monster.state="CHASING" } 
                else if(monster.pos.x===monster.lastKnownPlayerPos?.x&&monster.pos.y===monster.lastKnownPlayerPos?.y) { monster.state="RETURNING" } 
                break;
            case "RETURNING": 
                if(monster.pos.x===monster.spawnPos.x&&monster.pos.y===monster.spawnPos.y) { monster.state="IDLE" } 
                break;
        }
        let targetPos = null;
        if(monster.state==="CHASING") targetPos = gameState.playerPos;
        else if(monster.state==="SEARCHING") targetPos = monster.lastKnownPlayerPos;
        else if(monster.state==="RETURNING") targetPos = monster.spawnPos;
        
        if (targetPos) { 
            const path = findPath(monster.pos, targetPos); 
            if (path && path.length > 1) { 
                monster.pos = path[1]; 
            } else if (monster.state === "SEARCHING" && !path) {
                // å¦‚æœåœ¨ SEARCHING ç‹€æ…‹ä½†æ‰¾ä¸åˆ°è·¯å¾‘ï¼Œå¯èƒ½æ˜¯ç©å®¶å¾æœªçŸ¥çš„é»ç§»èµ°ï¼Œæˆ–ç›®æ¨™é»è¢«é˜»æ“‹ï¼Œæ­¤æ™‚è®“æ€ªç‰©è¿”å›
                monster.state = "RETURNING";
            }
        }
    }

    function checkPlayerPosition() {
        if (gameSession.isPaused) return;

        // 1. æª¢æŸ¥æ˜¯å¦æ‰¾åˆ°å¯¶è—ï¼ˆå­—ï¼‰
        for (let i = 0; i < gameState.treasures.length; i++) {
            const treasure = gameState.treasures[i];
            // åªæœ‰æœªæ‰¾åˆ°çš„å¯¶è—æ‰èƒ½è¢«æ”¶é›†
            if (!treasure.found && gameState.playerPos.x === treasure.pos.x && gameState.playerPos.y === treasure.pos.y) {
                
                treasure.found = true; // æ¨™è¨˜ç‚ºç•¶å‰éŠæˆ²ä¸­å·²æ‰¾åˆ°
                gameState.foundTreasuresCount++; // ç•¶å‰éŠæˆ²å›åˆæ‰¾åˆ°çš„æ•¸é‡å¢åŠ 
                
                // æ‰¾åˆ°è©²å­—åœ¨ TREASURE_CHARS ä¸­çš„ç´¢å¼•
                const charIndex = TREASURE_CHARS.indexOf(treasure.originalChar); // ä½¿ç”¨ originalChar
                if (charIndex !== -1) {
                    gameState.foundChars[charIndex] = treasure.originalChar; // æ›´æ–°ç•¶å‰éŠæˆ²çš„é¡¯ç¤ºå­—æ¨£
                    foundCharactersPersistent[charIndex] = true; // æ›´æ–°æŒä¹…åŒ–ç‹€æ…‹
                    updateFoundCharsDisplay(); // æ›´æ–° UI é¡¯ç¤º
                }
                
                // æ›´æ–°å·²æ‰¾åˆ°çš„å¯¶è—çš„å¤–è§€ï¼Œå¾ ğŸ è®Šç‚º ğŸ“¦
                const treasureEl = document.getElementById(treasure.id);
                if (treasureEl) {
                    treasureEl.textContent = 'ğŸ“¦';
                    treasureEl.classList.add('found-item'); // æ·»åŠ æ¨£å¼è®“å®ƒè®Šæš—/ä¸åŒ
                }
                
                showNotification(`æ­å–œä½ æ‰¾åˆ°äº†ã€Œ${treasure.originalChar}ã€ï¼`); // é¡¯ç¤ºæ‰¾åˆ°å“ªå€‹å­—çš„é€šçŸ¥
                
                // å¦‚æœæ‰€æœ‰é è¨­çš„å¯¶è—éƒ½å·²ç¶“è¢«æ‰¾åˆ° (åŒ…æ‹¬ä¹‹å‰å›åˆæ‰¾åˆ°çš„)
                if (foundCharactersPersistent.every(isFound => isFound)) {
                    winGame();
                    return; // éŠæˆ²çµæŸ
                }
            }
        }

        // 2. æª¢æŸ¥æ˜¯å¦è¢«æ€ªç‰©æŠ“åˆ°
        for (const monster of gameState.monsters) { 
            // ä¿®æ­£ï¼šæª¢æŸ¥ç©å®¶çš„ X å’Œ Y åº§æ¨™æ˜¯å¦éƒ½èˆ‡æ€ªç‰©ç›¸åŒ
            if (monster.pos.x === gameState.playerPos.x && monster.pos.y === gameState.playerPos.y) { 
                gameOver(); 
                return; 
            } 
        }
    }

    // --- éŠæˆ²æµç¨‹ ---
    function winGame() { 
        clearGameListeners(); 
        showScreen("win"); 
        initConfetti(); // åˆå§‹åŒ–å½©å¸¶canvas
        triggerNextConfettiBurstSequence(); // é–‹å§‹å½©å¸¶å‹•ç•«
    }
    function gameOver() { clearGameListeners(); showScreen("gameOver"); }

    function startGame(resetPersistent = true) { // å¢åŠ ä¸€å€‹åƒæ•¸ï¼Œæ§åˆ¶æ˜¯å¦é‡ç½®æŒä¹…åŒ–ç‹€æ…‹
        clearGameListeners(); // æ¸…é™¤ä¹‹å‰çš„ç›£è½å™¨å’ŒéŠæˆ²ç‹€æ…‹ï¼ŒåŒ…æ‹¬æ‰€æœ‰æ´»å‹•çš„é£›é¢
        
        gameState.bombsRemaining = levelConfig.initialBombs;
        gameState.placedBombs = [];
        gameState.dartsRemaining = levelConfig.initialDarts; // åˆå§‹åŒ–é£›é¢æ•¸é‡
        gameState.activeDarts = []; // æ¸…ç©ºé£›è¡Œä¸­çš„é£›é¢
        gameState.foundTreasuresCount = 0; // é‡ç½®ç•¶å‰éŠæˆ²å›åˆçš„å¯¶è—è¨ˆæ•¸
        gameState.foundChars = ['', '', '']; // é‡ç½®ç•¶å‰éŠæˆ²å›åˆçš„å­—æ¨£é¡¯ç¤º
        gameState.playerLastDirection = 'right'; // é‡ç½®ç©å®¶æœ€å¾Œæ–¹å‘ï¼ˆé è¨­å€¼ï¼‰

        // é‡ç½®ç§»å‹•ç‹€æ…‹
        playerMovement.activeKeyboardDirections.clear();
        playerMovement.joystickDirection = null;
        playerMovement.currentExecutingDirection = null;
        playerMovement.nextDesiredDirection = null;
        playerMovement.lastPos = { x: -1, y: -1 };


        if (resetPersistent) { // åªæœ‰ç•¶å¾é–‹å§‹ç•«é¢é»æ“Šæ™‚æ‰é‡ç½®æŒä¹…åŒ–ç‹€æ…‹
            foundCharactersPersistent.fill(false);
        }

        // æ ¹æ“šæŒä¹…åŒ–ç‹€æ…‹åˆå§‹åŒ– gameState.foundChars å’Œ gameState.foundTreasuresCount
        TREASURE_CHARS.forEach((char, index) => {
            if (foundCharactersPersistent[index]) {
                gameState.foundChars[index] = char;
            }
        });
        // é‡æ–°è¨ˆç®— foundTreasuresCount ä»¥ç¢ºä¿æ­£ç¢ºåæ˜ æŒä¹…åŒ–ç‹€æ…‹ä¸­å·²æ‰¾åˆ°çš„å­—
        gameState.foundTreasuresCount = foundCharactersPersistent.filter(Boolean).length;


        updateBombUI();
        updateDartUI(); // æ›´æ–°é£›é¢ UI
        updateFoundCharsDisplay(); // æ ¹æ“šåˆå§‹åŒ–å¾Œçš„ gameState.foundChars æ›´æ–° UI
        
        gameSession = { currentMoveSpeed: 120, isPaused: false };
        const playerSeed = 'Yen-Lin-Birthday-Hero';
        playerEl.style.backgroundImage = `url(https://api.dicebear.com/8.x/adventurer/svg?seed=${playerSeed}&radius=50)`;
        
        renderMaze(); // é€™æœƒå‘¼å« placeTreasureAndMonsters()
        computeFov();
        updateFovDisplay();
        showScreen('game');
        centerViewOnPlayer(false);
        
        // é‡æ–°æ·»åŠ éµç›¤ç›£è½å™¨
        document.addEventListener('keydown', handleKeyDown); 
        document.addEventListener('keyup', handleKeyUp);
        // è¨­ç½® UI ç›£è½å™¨ (åŒ…æ‹¬æ–æ¡¿å’ŒæŒ‰éˆ•)
        setupGameUIForDevice(); 
        playerMovement.moveInterval = setInterval(mainGameLoop, gameSession.currentMoveSpeed);

        setTimeout(() => {
            // ä¿®æ­£é–‹å§‹æç¤ºï¼Œä¸é¡¯ç¤ºå­—
            showNotification(`çˆ¶è¦ªç¯€å¿«æ¨‚ï¼æ‰¾åˆ°ä¸‰å€‹éš±è—çš„ç¦®ç‰©ï¼Œå³å¯é€šé—œï¼ä¸¦ç‚ºä½ æº–å‚™äº†${levelConfig.initialBombs}å€‹ç‚¸å½ˆ (æŒ‰ç©ºç™½éµæˆ–é»æ“Šå³ä¸‹è§’æŒ‰éˆ•ä½¿ç”¨)ï¼Œä»¥åŠ${levelConfig.initialDarts}å€‹é£›é¢ (æŒ‰ F éµæˆ–é»æ“Šå³ä¸‹è§’æŒ‰éˆ•ä½¿ç”¨)ï¼`);
        }, 500);
    }
    
    // --- è¿·å®®ç”Ÿæˆèˆ‡æ¸²æŸ“ ---
    function renderMaze() {
        mazeEl.innerHTML = ""; // æ¸…ç©ºèˆŠè¿·å®®
        gameState.monsters = [];
        gameState.treasures = []; // æ¸…ç©ºèˆŠå¯¶è— (é€™å°‡åœ¨ placeTreasureAndMonsters ä¸­é‡æ–°å¡«å……)
        gameState.mazeData = generateMaze(levelConfig.w, levelConfig.h, Date.now());
        placeTreasureAndMonsters(); // æ”¾ç½®å¯¶è—å’Œæ€ªç‰©

        const mazeWidth = gameState.mazeData[0].length;
        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size').trim());
        mazeEl.style.gridTemplateColumns = `repeat(${mazeWidth}, ${cellSize}px)`;
        let content = "";
        gameState.mazeData.forEach((row, y) => {
            row.forEach((cellType, x) => {
                let cellClass = "";
                if (cellType === "S") { gameState.playerPos = { x, y }; cellClass = "start"; }
                else if (cellType === "W") cellClass = "wall";
                else if (cellType === "P") cellClass = "path";
                else if (cellType === "T") { cellClass = "treasure-location"; } // å¯¶è—ä½ç½®çš„èƒŒæ™¯è‰²
                content += `<div class="grid-cell ${cellClass}" id="cell-${x}-${y}"></div>`;
            })
        });
        mazeEl.innerHTML = content;
        
        // æ¸²æŸ“æ€ªç‰©
        gameState.monsters.forEach(monster => {
            const el = document.createElement("div");
            el.id = `monster-${monster.id}`;
            el.className = "monster";
            el.style.backgroundImage = `url(https://api.dicebear.com/8.x/bottts-neutral/svg?seed=${monster.id}&radius=8&backgroundColor=d1d1d1)`;
            el.style.transform = `translate(${monster.pos.x * cellSize}px, ${monster.pos.y * cellSize}px)`;
            el.style.filter = monster.colorFilter;
            mazeEl.appendChild(el);
        });

        // æ¸²æŸ“å¯¶è— (æ–°çš„é‚è¼¯ï¼Œæ¯å€‹å¯¶è—ç¨ç«‹å‰µå»º)
        gameState.treasures.forEach(treasure => {
            // æª¢æŸ¥ treasure.pos æ˜¯å¦å­˜åœ¨ï¼Œé¿å…éŒ¯èª¤
            if (!treasure.pos) {
                console.warn(`Treasure ${treasure.originalChar} has no position and will not be rendered.`);
                return; 
            }
            const el = document.createElement("div");
            el.id = treasure.id;
            el.className = "treasure";
            el.textContent = treasure.displayChar; // é¡¯ç¤º ğŸ æˆ– ğŸ“¦
            // ä¿®æ­£å¯¶è—å®šä½ï¼Œä½¿å…¶ä¸­å¿ƒä½æ–¼æ ¼å­ä¸­å¿ƒ
            el.style.left = `${treasure.pos.x * cellSize + cellSize / 2}px`;
            el.style.top = `${treasure.pos.y * cellSize + cellSize / 2}px`;
            if (treasure.found) { // å¦‚æœé€™å€‹å¯¶è—å·²ç¶“åœ¨æŒä¹…åŒ–ç‹€æ…‹ä¸­è¢«æ‰¾åˆ°ï¼Œçµ¦å®ƒä¸€å€‹ç‰¹æ®Šæ¨£å¼
                el.classList.add('found-item');
            }
            mazeEl.appendChild(el);
        });
    }

    // --- æ€ªç‰©èˆ‡å¯¶ç®±æ”¾ç½® ---
    function placeTreasureAndMonsters() {
        const rng = seededRandom(Date.now());
        let allDeadEnds = [];

        // æ‰¾å‡ºæ‰€æœ‰è·é›¢èµ·é»å¤ é çš„æ­»è·¯
        for (let y = 1; y < gameState.mazeData.length - 1; y++) {
            for (let x = 1; x < gameState.mazeData[y].length - 1; x++) {
                if (gameState.mazeData[y][x] === 'P') {
                    let wallCount = 0;
                    if (gameState.mazeData[y-1][x] === 'W') wallCount++;
                    if (gameState.mazeData[y+1][x] === 'W') wallCount++;
                    if (gameState.mazeData[y][x-1] === 'W') wallCount++;
                    if (gameState.mazeData[y][x+1] === 'W') wallCount++;
                    if (wallCount >= 3) {
                        if (getDistance({ x, y }, { x: 1, y: 1 }) > 5) { // ç¢ºä¿è·é›¢èµ·é»å¤ é 
                            allDeadEnds.push({x, y});
                        }
                    }
                }
            }
        }
        allDeadEnds.sort(() => rng() - 0.5); // éš¨æ©Ÿæ‰“äº‚æ­»è·¯é †åº

        gameState.treasures = [];
        const treasuresToPlaceInThisRound = []; // ç•¶å‰å›åˆéœ€è¦å¯¦éš›æ”¾ç½®çš„ç¦®ç‰© (æœªæ‰¾åˆ°çš„)
        const treasuresAlreadyFound = []; // ä¹‹å‰å·²ç¶“æ‰¾åˆ°çš„ç¦®ç‰© (ä½œç‚ºä½”ä½ç¬¦)

        // 1. è™•ç†æ‰€æœ‰å¯¶è—ï¼šå·²æ‰¾åˆ°çš„ä½œç‚ºä½”ä½ç¬¦ï¼Œæœªæ‰¾åˆ°çš„æº–å‚™æ”¾ç½®
        TREASURE_CHARS.forEach((char, index) => {
            if (!foundCharactersPersistent[index]) {
                // å¦‚æœé€™å€‹å­—é‚„æ²’æ‰¾åˆ°ï¼Œå°±æº–å‚™åœ¨è¿·å®®ä¸­æ”¾ç½®å®ƒ
                treasuresToPlaceInThisRound.push({ originalChar: char, id: `treasure-${char}`, found: false, displayChar: 'ğŸ' });
            } else {
                // å¦‚æœå·²ç¶“æ‰¾åˆ°ï¼Œä½œç‚ºä¸€å€‹å·²æ‰“é–‹çš„ç©ºç›’å­ä½”ä½
                treasuresAlreadyFound.push({ originalChar: char, id: `treasure-${char}`, found: true, displayChar: 'ğŸ“¦' });
            }
        });
        
        // å°‡æœªæ‰¾åˆ°çš„å¯¶è—éš¨æ©Ÿæ‰“äº‚ï¼Œä»¥ä¾¿åˆ†é…åˆ°æ­»è·¯
        treasuresToPlaceInThisRound.sort(() => rng() - 0.5);

        // 2. å„ªå…ˆç‚ºç•¶å‰å›åˆæœªæ‰¾åˆ°çš„å¯¶è—åˆ†é…ä½ç½®
        for (const t of treasuresToPlaceInThisRound) {
            if (allDeadEnds.length > 0) {
                const tPos = allDeadEnds.pop();
                t.pos = tPos;
                gameState.mazeData[tPos.y][tPos.x] = "T"; // æ¨™è¨˜ç‚ºå¯¶è—ä½ç½®
                gameState.treasures.push(t); // å°‡å¯¶è—åŠ å…¥åˆ°éŠæˆ²ç‹€æ…‹ä¸­
            } else {
                console.warn(`WARN: Not enough dead ends to place new treasure: ${t.originalChar}. It will not appear this round.`);
                // æ²’æœ‰è¶³å¤ çš„æ­»è·¯ï¼Œå¯¶è—å°‡ä¸æœƒè¢«æ”¾ç½®
            }
        }

        // 3. ç‚ºå·²æ‰¾åˆ°çš„å¯¶è—ï¼ˆä½”ä½ç¬¦ï¼‰åˆ†é…ä½ç½® (å¦‚æœé‚„æœ‰æ­»è·¯)
        for (const t of treasuresAlreadyFound) {
            if (allDeadEnds.length > 0) {
                const tPos = allDeadEnds.pop();
                t.pos = tPos;
                gameState.mazeData[tPos.y][tPos.x] = "T";
                gameState.treasures.push(t); // å°‡å·²æ‰¾åˆ°çš„å¯¶è—åŠ å…¥åˆ°éŠæˆ²ç‹€æ…‹ä¸­
            } else {
                console.warn(`WARN: Not enough dead ends for already found treasure: ${t.originalChar}. It will not appear on the map.`);
                // å¦‚æœæ²’æœ‰è¶³å¤ çš„æ­»è·¯ï¼Œå·²æ‰¾åˆ°çš„å¯¶è—å°‡ä¸æœƒè¢«æ”¾ç½®
            }
        }


        // 4. æ”¾ç½®æ€ªç‰©ï¼Œåªä½¿ç”¨å‰©é¤˜çš„æ­»è·¯
        gameState.monsters = [];
        for (let i = 0; i < levelConfig.m; i++) {
            if (allDeadEnds.length > 0) { // æª¢æŸ¥æ˜¯å¦é‚„æœ‰æ­»è·¯å¯ä»¥æ”¾æ€ªç‰©
                const spawnPoint = allDeadEnds.pop();
                const tier = MONSTER_TIERS[Math.floor(rng() * MONSTER_TIERS.length)];
                gameState.monsters.push({ ...tier, id: i, pos: { ...spawnPoint }, spawnPos: { ...spawnPoint }, state: 'IDLE', lastKnownPlayerPos: null, moveCooldown: 0 });
            } else {
                console.warn(`WARN: Not enough dead ends left for all ${levelConfig.m} monsters. Placed ${i} monsters.`);
                break; // æ²’æœ‰è¶³å¤ çš„æ­»è·¯å¯ä»¥æ”¾æ€ªç‰©äº†
            }
        }
    }

    function generateMaze(w, h, seed) {
        const rng = seededRandom(seed);
        const grid = Array.from({ length: h * 2 + 1 }, () => Array(w * 2 + 1).fill("W"));
        function carve(cx, cy) { const dirs = ["N", "S", "E", "W"].sort(() => rng() - .5); for (const d of dirs) { const[dx,dy]={N:[0,-2],S:[0,2],E:[2,0],W:[-2,0]}[d]; const nx=cx+dx, ny=cy+dy; if(ny>=0&&ny<h*2+1&&nx>=0&&nx<w*2+1&&grid[ny][nx]==="W"){grid[ny-dy/2][nx-dx/2]="P";grid[ny][nx]="P";carve(nx,ny)} } }
        grid[1][1] = "P"; carve(1, 1); grid[1][1] = "S"; return grid;
    }

    // --- ç‚¸å½ˆèˆ‡çˆ†ç‚¸åŠŸèƒ½ ---
    function placeBomb() {
        if (gameSession.isPaused) return;
        if (gameState.bombsRemaining <= 0) {
            showNotification("ä½ æ²’æœ‰ç‚¸å½ˆäº†ï¼");
            return;
        }
        const {x, y} = gameState.playerPos;
        if (gameState.placedBombs.some(bomb => bomb.x === x && bomb.y === y)) {
            showNotification("é€™å€‹ä½ç½®å·²ç¶“æœ‰ç‚¸å½ˆäº†ï¼");
            return;
        }

        gameState.bombsRemaining--;
        updateBombUI();
        
        const bombPos = {x, y};
        gameState.placedBombs.push(bombPos);

        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size').trim());
        const bombEl = document.createElement('div');
        bombEl.id = `bomb-${bombPos.x}-${bombPos.y}`;
        bombEl.className = 'bomb';
        bombEl.textContent = 'ğŸ’£';
        // ä¿®æ­£ç‚¸å½ˆå®šä½ï¼Œä½¿å…¶ä¸­å¿ƒä½æ–¼æ ¼å­ä¸­å¿ƒ
        bombEl.style.left = `${bombPos.x * cellSize + cellSize / 2}px`;
        bombEl.style.top = `${bombPos.y * cellSize + cellSize / 2}px`;
        mazeEl.appendChild(bombEl);
    }
    
    function updateBombUI() { bombCountTextSpan.textContent = gameState.bombsRemaining; } // Access span directly

    function triggerExplosion(x, y) {
        const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size').trim());
        const explosionEl = document.createElement('div');
        explosionEl.className = 'explosion';
        explosionEl.textContent = 'ğŸ’¥';
        // ä¿®æ­£çˆ†ç‚¸å®šä½ï¼Œä½¿å…¶ä¸­å¿ƒä½æ–¼æ ¼å­ä¸­å¿ƒ
        explosionEl.style.left = `${x * cellSize + cellSize / 2}px`;
        explosionEl.style.top = `${y * cellSize + cellSize / 2}px`;
        mazeEl.appendChild(explosionEl);
        setTimeout(() => { explosionEl.remove(); }, 500); // å‹•ç•«çµæŸå¾Œç§»é™¤
    }

    function checkBombCollisions() {
        const monstersToRemove = new Set();
        const bombsToRemove = [];

        for (const monster of gameState.monsters) {
            const bombIndex = gameState.placedBombs.findIndex(b => b.x === monster.pos.x && b.y === monster.pos.y);
            if (bombIndex > -1) {
                monstersToRemove.add(monster.id);
                const bombPos = gameState.placedBombs[bombIndex];
                bombsToRemove.push(bombPos);
                triggerExplosion(bombPos.x, bombPos.y);
            }
        }

        if (monstersToRemove.size > 0) {
            // ç§»é™¤æ€ªç‰©
            gameState.monsters = gameState.monsters.filter(m => !monstersToRemove.has(m.id));
            monstersToRemove.forEach(id => document.getElementById(`monster-${id}`)?.remove());

            // ç§»é™¤ç‚¸å½ˆ
            gameState.placedBombs = gameState.placedBombs.filter(b => !bombsToRemove.some(br => br.x === b.x && br.y === b.y));
            bombsToRemove.forEach(b => document.getElementById(`bomb-${b.x}-${b.y}`)?.remove());
        }
    }

    // --- é£›é¢åŠŸèƒ½ ---
    function updateDartUI() { dartCountTextSpan.textContent = gameState.dartsRemaining; } // Access span directly

    function shootDart() {
        if (gameSession.isPaused) return;
        if (gameState.dartsRemaining <= 0) {
            showNotification("ä½ æ²’æœ‰é£›é¢äº†ï¼");
            return;
        }
        // æ•æ‰ç©å®¶æœ€å¾Œçš„ç§»å‹•æ–¹å‘ï¼Œå¦‚æœç©å®¶é‚„æ²’å‹•ï¼Œé è¨­å‘å³
        const dartDirection = gameState.playerLastDirection;
        // å·²ç§»é™¤éœæ­¢æ™‚ç„¡æ³•ç™¼å°„çš„æª¢æŸ¥ï¼Œé è¨­å‘å³æˆ–ä½¿ç”¨æœ€å¾Œæ–¹å‘

        gameState.dartsRemaining--;
        updateDartUI();

        let dartPos = { ...gameState.playerPos };
        const dartId = `dart-${Date.now()}`;
        const dartEl = document.createElement('div');
        dartEl.id = dartId;
        dartEl.className = 'dart';
        dartEl.textContent = 'ğŸªƒ'; // é£›é¢ emoji
        mazeEl.appendChild(dartEl);

        const dart = { id: dartId, pos: dartPos, direction: dartDirection, element: dartEl, intervalId: null };
        gameState.activeDarts.push(dart);

        const dartMoveSpeed = gameSession.currentMoveSpeed / 3; // é£›é¢é€Ÿåº¦æ¯”ç©å®¶å¿«3å€

        dart.intervalId = setInterval(() => {
            if (gameSession.isPaused) return;

            let nextPos = { ...dart.pos };
            if (dart.direction === 'up') nextPos.y--;
            else if (dart.direction === 'down') nextPos.y++;
            else if (dart.direction === 'left') nextPos.x--;
            else if (dart.direction === 'right') nextPos.x++;

            // æª¢æŸ¥æ˜¯å¦è¶…å‡ºè¿·å®®ç¯„åœæˆ–ç¢°åˆ°ç‰†å£
            const mazeHeight = gameState.mazeData.length;
            const mazeWidth = gameState.mazeData[0].length;
            if (nextPos.x < 0 || nextPos.x >= mazeWidth ||
                nextPos.y < 0 || nextPos.y >= mazeHeight ||
                gameState.mazeData[nextPos.y][nextPos.x] === "W") { // ç›´æ¥æª¢æŸ¥ä¸‹ä¸€å€‹ä½ç½®æ˜¯å¦æ˜¯ç‰†å£
                clearInterval(dart.intervalId);
                dart.element.remove();
                gameState.activeDarts = gameState.activeDarts.filter(d => d.id !== dart.id);
                return;
            }

            dart.pos = nextPos;
            const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size').trim());
            // ä¿®æ­£é£›é¢å®šä½ï¼Œä½¿å…¶ä¸­å¿ƒä½æ–¼æ ¼å­ä¸­å¿ƒ
            dart.element.style.left = `${dart.pos.x * cellSize + cellSize / 2}px`;
            dart.element.style.top = `${dart.pos.y * cellSize + cellSize / 2}px`;

            // æª¢æŸ¥æ˜¯å¦å‘½ä¸­æ€ªç‰©
            const monsterHitIndex = gameState.monsters.findIndex(m => m.pos.x === dart.pos.x && m.pos.y === dart.pos.y);
            if (monsterHitIndex !== -1) {
                const monsterId = gameState.monsters[monsterHitIndex].id;
                document.getElementById(`monster-${monsterId}`)?.remove();
                gameState.monsters.splice(monsterHitIndex, 1); //å¾æ€ªç‰©é™£åˆ—ä¸­ç§»é™¤
                clearInterval(dart.intervalId);
                dart.element.remove(); // ç§»é™¤é£›é¢å…ƒç´ 
                gameState.activeDarts = gameState.activeDarts.filter(d => d.id !== dart.id);
                showNotification("æ€ªç‰©è¢«é£›é¢æ¶ˆæ»…äº†ï¼");
                return;
            }
        }, dartMoveSpeed);
    }


    // --- é€šçŸ¥åŠŸèƒ½ ---
    function showNotification(message) { pauseGame(); notificationText.innerHTML = message; notificationOverlay.classList.add('active'); }
    function hideNotification() { notificationOverlay.classList.remove('active'); resumeGame(); }

    // --- æ›´æ–°æ‰¾åˆ°çš„å­—æ¨£ UI ---
    function updateFoundCharsDisplay() {
        charSpans.forEach((span, index) => {
            span.textContent = gameState.foundChars[index] || '_'; // é¡¯ç¤ºå·²æ‰¾åˆ°çš„å­—ï¼Œæˆ–åº•ç·š
        });
    }

    // --- å½©å¸¶ç‰¹æ•ˆåŠŸèƒ½ ---
    function initConfetti() {
        confettiCanvas = document.getElementById('confetti-canvas');
        if (!confettiCanvas) return; 
        confettiCtx = confettiCanvas.getContext('2d');
        resizeConfettiCanvas();
        window.addEventListener('resize', resizeConfettiCanvas);
        // Ensure drawConfetti loop is running
        if (!confettiAnimationId) {
            drawConfetti();
        }
    }

    function resizeConfettiCanvas() {
        if (confettiCanvas) {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        }
    }

    function createConfettiParticle(spawnX, spawnY, initialSide) {
        const radius = Math.random() * 5 + 2; // å½©å¸¶å¤§å°
        const colors = ['#f1c40f', '#e67e22', '#e74c3c', '#2ecc71', '#3498db', '#9b59b6']; // é®®è±”çš„é¡è‰²
        const color = colors[Math.floor(Math.random() * colors.length)];
        
        // åˆå§‹é€Ÿåº¦ï¼šæ°´å¹³å‘å¤–å™´å°„ï¼Œå‚ç›´å‘ä¸Šå¾®å™´
        const initialHorizontalBurstSpeed = Math.random() * 12 + 8; // è¼ƒå¤§çš„æ°´å¹³å™´å°„åŠ›é“
        const initialVerticalBurstSpeed = Math.random() * -10 - 5; // è² å€¼ä½¿å…¶å‘ä¸Šå™´å°„
        
        const velocityX = initialHorizontalBurstSpeed * (initialSide === 'left' ? 1 : -1);
        const velocityY = initialVerticalBurstSpeed;
        
        const gravity = 0.08; // è¼ƒå°çš„é‡åŠ›å€¼ï¼Œä½¿å…¶ç·©æ…¢ä¸‹è½ (å·²èª¿æ•´)
        const dampingFactor = 0.96; // é˜»å°¼ä¿‚æ•¸ï¼Œè®“é€Ÿåº¦é€æ¼¸æ¸›å°

        const rotation = Math.random() * Math.PI * 2;
        const rotationSpeed = Math.random() * 0.1 - 0.05; // è¼•å¾®æ—‹è½‰
        const opacity = 1;

        return { x: spawnX, y: spawnY, radius, color, 
                 velocityX, velocityY, gravity, dampingFactor,
                 rotation, rotationSpeed, opacity };
    }

    function drawConfetti() {
        if (!confettiCtx) return; // Add a check here
        confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

        // æ›´æ–°å’Œç¹ªè£½ç²’å­
        for (let i = confettiParticles.length - 1; i >= 0; i--) {
            const p = confettiParticles[i];

            // æ‡‰ç”¨é˜»å°¼ï¼Œä½¿é€Ÿåº¦æ¸›æ…¢
            p.velocityX *= p.dampingFactor;
            p.velocityY *= p.dampingFactor;

            p.x += p.velocityX;
            p.y += p.velocityY;
            p.velocityY += p.gravity; // æ‡‰ç”¨é‡åŠ›ï¼Œä½¿å…¶ä¸‹è½
            p.rotation += p.rotationSpeed;
            p.opacity -= 0.005; // é€æ¼¸æ·¡å‡º

            // ç§»é™¤è¶…å‡ºè¢å¹•æˆ–å·²æ·¡å‡ºçš„ç²’å­
            if (p.y > confettiCanvas.height + p.radius || p.x < -p.radius || p.x > confettiCanvas.width + p.radius || p.opacity <= 0) {
                confettiParticles.splice(i, 1); 
            } else {
                confettiCtx.save();
                confettiCtx.translate(p.x, p.y);
                confettiCtx.rotate(p.rotation);
                confettiCtx.globalAlpha = p.opacity;
                confettiCtx.fillStyle = p.color;
                // ç¹ªè£½æ­£æ–¹å½¢å½©å¸¶
                confettiCtx.fillRect(-p.radius, -p.radius, p.radius * 2, p.radius * 2); 
                confettiCtx.restore();
            }
        }
        confettiAnimationId = requestAnimationFrame(drawConfetti);
    }

    function triggerNextConfettiBurstSequence() { // Renamed from startConfettiEffect
        stopConfettiBursts(); // Ensure current sequence is stopped
        confettiParticles = []; // Clear particles for a fresh start
        currentBurstIndexInRound = 0; // Reset burst index

        // Immediately start the first burst in sequence
        performSingleConfettiBurst();
    }

    function performSingleConfettiBurst() {
        if (!confettiCanvas) return; // Add safety check

        const emitterIndex = burstOrderIndices[currentBurstIndexInRound];
        const currentY = confettiCanvas.height * emitterYPositions[emitterIndex];

        // From left side
        for (let i = 0; i < 15; i++) {
            confettiParticles.push(createConfettiParticle(0, currentY, 'left'));
        }
        // From right side
        for (let i = 0; i < 15; i++) {
            confettiParticles.push(createConfettiParticle(confettiCanvas.width, currentY, 'right'));
        }

        currentBurstIndexInRound++;

        if (currentBurstIndexInRound < burstOrderIndices.length) {
            // More bursts in this round, delay a bit for the next pair
            burstSequenceTimerId = setTimeout(performSingleConfettiBurst, burstBetweenPairsDelayMs);
        } else {
            // All pairs in this round have burst, reset for next round and apply long delay
            currentBurstIndexInRound = 0; // Reset for the next full sequence
            burstSequenceTimerId = setTimeout(performSingleConfettiBurst, delayBetweenRoundsMs); // 2 second delay for next round
        }
    }


    function stopConfetti() {
        if (confettiAnimationId) {
            cancelAnimationFrame(confettiAnimationId);
            confettiAnimationId = null;
        }
        stopConfettiBursts(); // Stop the timed bursts
        confettiParticles = []; // Clear particle array
        if (confettiCtx) confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height); // Clear canvas
        window.removeEventListener('resize', resizeConfettiCanvas);
    }

    function stopConfettiBursts() { // New function to stop only the timed particle bursts
        if (burstSequenceTimerId) {
            clearTimeout(burstSequenceTimerId);
            burstSequenceTimerId = null;
        }
    }

    // --- è¼”åŠ©å‡½æ•¸ ---
    function centerViewOnPlayer(animated = true) { const cellSize=parseInt(getComputedStyle(document.documentElement).getPropertyValue("--cell-size").trim()),cW=gameContainer.clientWidth,cH=gameContainer.clientHeight;const mX=-gameState.playerPos.x*cellSize+cW/2-cellSize/2,mY=-gameState.playerPos.y*cellSize+cH/2-cellSize/2;mazeEl.style.transition=animated?`transform ${gameSession.currentMoveSpeed}ms linear`:"none";mazeEl.style.transform=`translate(${mX}px, ${mY}px)`}
    let visibleCells = new Set();
    function computeFov() { visibleCells.clear(); visibleCells.add(`${gameState.playerPos.x},${gameState.playerPos.y}`); const octants=[{xx:1,xy:0,yx:0,yy:1},{xx:0,xy:1,yx:1,yy:0},{xx:0,xy:-1,yx:1,yy:0},{xx:-1,xy:0,yx:0,yy:1},{xx:-1,xy:0,yx:0,yy:-1},{xx:0,xy:-1,yx:-1,yy:0},{xx:0,xy:1,yx:-1,yy:0},{xx:1,xy:0,yx:0,yy:-1}]; octants.forEach(o => castLight(1,1,0,o.xx,o.xy,o.yx,o.yy)); }
    function castLight(row,start,end,xx,xy,yx,yy){ let newStart=0;if(start<end)return;let r2=FOV_RADIUS*FOV_RADIUS;for(let j=row;j<=FOV_RADIUS;j++){let dx=-j-1,dy=-j,blocked=!1;while(dx<=0){dx++;let mX=gameState.playerPos.x+dx*xx+dy*xy,mY=gameState.playerPos.y+dx*yx+dy*yy;if(mX<0||mX>=gameState.mazeData[0].length||mY<0||mY>=gameState.mazeData.length)continue;let lS=(dx-.5)/(dy+.5),rS=(dx+.5)/(dy-.5);if(start<rS)continue;else if(end>lS)break;if(dx*dx+dy*dy<r2)visibleCells.add(`${mX},${mY}`);let isWall=gameState.mazeData[mY]?.[mX]==="W";if(blocked){if(isWall){newStart=rS;continue}else{blocked=!1;start=newStart}}else{if(isWall&&j<FOV_RADIUS){blocked=!0;castLight(j+1,start,lS,xx,xy,yx,yy);newStart=rS}}}if(blocked)break}}
    function updateFovDisplay() {
        document.querySelectorAll(".grid-cell.visible").forEach(el=>el.classList.remove("visible"));
        visibleCells.forEach(key=>{const cell=document.getElementById(`cell-${key.replace(',','-')}`);if(cell)cell.classList.add("visible")});
        gameState.monsters.forEach(m=>{document.getElementById(`monster-${m.id}`)?.classList.toggle("visible",visibleCells.has(`${m.pos.x},${m.pos.y}`))});
        // æ›´æ–°å¤šå€‹å¯¶è—çš„é¡¯ç¤º
        gameState.treasures.forEach(t => {
            const treasureEl = document.getElementById(t.id);
            if (treasureEl) {
                // åªæœ‰æœªæ‰¾åˆ°çš„å¯¶è—æ‰å— FOV æ§åˆ¶ï¼Œå·²æ‰¾åˆ°çš„å¯¶è—æœƒä¿æŒå…¶ 'found-item' æ¨£å¼å’ŒåŠé€æ˜ç‹€æ…‹
                if (!t.found) {
                    treasureEl.classList.toggle("visible", visibleCells.has(`${t.pos.x},${t.pos.y}`));
                } else {
                    // å·²æ‰¾åˆ°çš„å¯¶è—ï¼Œåªè¦åœ¨åœ°åœ–ä¸Šï¼Œå°±ä¿æŒå¯è¦‹ (åŠé€æ˜)ï¼Œä¸è¢« FOV éš±è—
                    treasureEl.classList.add("visible");
                }
            }
        });
        // æ›´æ–°é£›è¡Œä¸­çš„é£›é¢é¡¯ç¤º
        gameState.activeDarts.forEach(d => {
            const dartEl = document.getElementById(d.id);
            if (dartEl) {
                // é£›é¢ä¸å— FOV å½±éŸ¿ï¼Œä¸€æ—¦ç™¼å°„å°±å§‹çµ‚å¯è¦‹
                dartEl.classList.add("visible"); 
            }
        });
    }
    function canMove(pos,dir){let newPos={...pos};if(dir==="up")newPos.y--;else if(dir==="down")newPos.y++;else if(dir==="left")newPos.x--;else if(dir==="right")newPos.x++;return gameState.mazeData[newPos.y]?.[newPos.x]&&gameState.mazeData[newPos.y][newPos.x]!=="W"}
    function getDistance(p1,p2){return Math.sqrt(Math.pow(p1.x-p2.x,2)+Math.pow(p1.y-p2.y,2))}
    function findPath(start,end){const q=[[start]],visited=new Set([`${start.x},${start.y}`]),dirs=["up","down","left","right"];while(q.length>0){const path=q.shift(),pos=path[path.length-1];if(pos.x===end.x&&pos.y===end.y)return path;for(const dir of dirs){let next={...pos};if(dir==="up")next.y--;else if(dir==="down")next.y++;else if(dir==="left")next.x--;else if(dir==="right")next.x++;const key=`${next.x},${next.y}`;if(!visited.has(key)&&canMove(pos,dir)){visited.add(key);q.push([...path,next])}}}return null}
    function isPlayerVisible(monsterPos,playerPos){if(getDistance(monsterPos,playerPos)>FOV_RADIUS)return!1;let x0=monsterPos.x,y0=monsterPos.y;const x1=playerPos.x,y1=playerPos.y;const dx=Math.abs(x1-x0),sx=x0<x1?1:-1;const dy=-Math.abs(y1-y0),sy=y0<y1?1:-1;let err=dx+dy,e2;while(!0){if(gameState.mazeData[y0]?.[x0]==="W")return!1;if(x0===x1&&y0===y1)break;e2=2*err;if(e2>=dy){err+=dy;x0+=sx}if(e2<=dx){err+=dx;y0+=sy}}return!0}
    
    // Keyboard Input Handling (for both movement and actions)
    const MOVE_KEY_MAP = {
        ArrowUp: "up", w: "up",
        ArrowDown: "down", s: "down",
        ArrowLeft: "left", a: "left",
        ArrowRight: "right", d: "right"
    };

    function handleKeyDown(e){ 
        if (gameSession.isPaused) return; 

        // Handle Action Keys (independent of movement)
        if (e.code === 'Space' || e.key === ' ') { 
            e.preventDefault(); 
            placeBomb(); 
            return; // Stop processing this event as it was for an action
        }
        if (e.key === 'f' || e.key === 'F' || e.key === 'é›¢') { 
            e.preventDefault();
            shootDart();
            return; // Stop processing this event as it was for an action
        }

        // Handle Movement Keys
        const direction = MOVE_KEY_MAP[e.key];
        if (direction) {
            // Add the direction to the set of currently active keyboard movement keys
            playerMovement.activeKeyboardDirections.add(direction);
            e.preventDefault(); // Prevent default browser actions (like scrolling)
        }
    }

    function handleKeyUp(e){ 
        if (gameSession.isPaused) return; 

        // For movement keys, remove from active set
        const direction = MOVE_KEY_MAP[e.key];
        if (direction) {
            playerMovement.activeKeyboardDirections.delete(direction);
        }
        // Action keys don't affect movement state, so no need to handle keyup for them here
    }

    // Joystick Input Handling (for movement only, independent of action buttons)
    let isJoystickDragging=!1,joystickOrigin={x:0,y:0},maxJoystickRadius=0;
    function joystickTouchStart(e){
        // Only prevent default on the joystick handle itself or the base if touch initiates drag
        if (e.target === joystickHandle || e.target === joystickContainer) {
            e.preventDefault(); 
        }
        isJoystickDragging=!0;
        const r=joystickContainer.getBoundingClientRect();
        joystickOrigin={x:r.left+r.width/2,y:r.top+r.height/2};
        maxJoystickRadius=joystickContainer.offsetWidth/2-joystickHandle.offsetWidth/2;
        joystickTouchMove(e); // Process initial touch as a move
    }
    function joystickTouchMove(e){
        if(!isJoystickDragging)return;
        // Only prevent default on the joystick handle or base during drag
        if (e.target === joystickHandle || e.target === joystickContainer) {
            e.preventDefault(); 
        } else {
             // If touch moves outside joystick area, but still dragging, allow default
             // This can happen if user drags off the joystick, but we still want to process movement until lift
        }
        
        const t=e.touches[0];
        let dx=t.clientX-joystickOrigin.x,dy=t.clientY-joystickOrigin.y;
        const dist=Math.sqrt(dx*dx+dy*dy);
        if(dist>maxJoystickRadius){dx=dx/dist*maxJoystickRadius;dy=dy/dist*maxJoystickRadius}
        joystickHandle.style.transform=`translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
        
        // Determine joystick direction and set it directly
        let d = null;
        if(dist < 20) { // Joystick near center, no movement
            d = null;
        } else if(Math.abs(dx) > Math.abs(dy)){ // Horizontal movement
            d = dx > 0 ? "right" : "left";
        } else { // Vertical movement
            d = dy > 0 ? "down" : "up";
        }
        playerMovement.joystickDirection = d; // Joystick directly controls this direction
    }
    function joystickTouchEnd(e){
        if(!isJoystickDragging)return;
        // Prevent default only if touch ended on joystick area itself, to avoid triggering click on button
        if (e.target === joystickHandle || e.target === joystickContainer) {
             e.preventDefault();
        }
        isJoystickDragging=!1;
        joystickHandle.style.transform="translate(-50%, -50%)";
        playerMovement.joystickDirection = null; // Stop movement when joystick released
    }
    
    // Control UI elements visibility and attach/detach event listeners
    // Named functions for button touchstart to allow proper removal
    const handlePlaceBombTouch = (e) => { e.preventDefault(); placeBomb(); };
    const handleShootDartTouch = (e) => { e.preventDefault(); shootDart(); };

    function setupGameUIForDevice() {
        if (isTouchDevice) {
            joystickContainer.style.display = 'block';
            // Attach joystick listeners for touch devices
            joystickContainer.addEventListener("touchstart", joystickTouchStart, { passive: false }); 
            // Note: touchmove/touchend are on document because user might drag off joystick
            document.addEventListener("touchmove", joystickTouchMove, { passive: false }); 
            document.addEventListener("touchend", joystickTouchEnd, { passive: false }); 
            document.addEventListener("touchcancel", joystickTouchEnd, { passive: false }); 

            // Attach touchstart listeners for action buttons
            placeBombBtn.addEventListener("touchstart", handlePlaceBombTouch, { passive: false });
            shootDartBtn.addEventListener("touchstart", handleShootDartTouch, { passive: false });
            // Ensure buttons are visible for touch devices
            placeBombBtn.style.display = 'flex'; 
            shootDartBtn.style.display = 'flex';
        } else { // Desktop
            joystickContainer.style.display = 'none'; // No joystick on desktop
            placeBombBtn.style.display = 'flex'; // Buttons visible (for mouse click / visual cue for keyboard)
            shootDartBtn.style.display = 'flex';
            // Desktop buttons use click listeners already set up at bottom of DOMContentLoaded, no touchstart needed here
        }
    }

    function removeGameUIListeners() { // Renamed to clearly state it removes LISTENERS
        joystickContainer.removeEventListener("touchstart", joystickTouchStart); 
        document.removeEventListener("touchmove", joystickTouchMove); 
        document.removeEventListener("touchend", joystickTouchEnd); 
        document.removeEventListener("touchcancel", joystickTouchEnd); 

        placeBombBtn.removeEventListener("touchstart", handlePlaceBombTouch);
        shootDartBtn.removeEventListener("touchstart", handleShootDartTouch);
    }

    function removeGameUIElementsDisplay() { // To hide the actual UI elements
        joystickContainer.style.display = 'none';
        placeBombBtn.style.display = 'none';
        shootDartBtn.style.display = 'none';
    }


    function clearGameListeners() { 
        if(playerMovement.moveInterval) clearInterval(playerMovement.moveInterval); 
        playerMovement.moveInterval = null; 
        document.removeEventListener("keydown", handleKeyDown); 
        document.removeEventListener("keyup", handleKeyUp); 
        removeGameUIListeners(); // Call the specific listener removal function
        removeGameUIElementsDisplay(); // Call the UI hiding function
        // Clear all flying darts intervals and remove their elements
        gameState.activeDarts.forEach(dart => {
            clearInterval(dart.intervalId);
            if (dart.element) dart.element.remove();
        });
        gameState.activeDarts = [];
    }

    // --- äº‹ä»¶ç›£è½å™¨èˆ‡åˆå§‹åŒ– ---
    document.getElementById('start-game-btn').addEventListener('click', () => {
        setupGameUIForDevice(); // Show/setup UI elements based on device
        startGame(true); // Start a new game, resetting persistent progress
    });
    document.getElementById('retry-btn').addEventListener('click', () => { 
        setupGameUIForDevice(); // Show/setup UI elements based on device
        clearGameListeners(); // Clear previous game state and listeners
        startGame(false); // Retry current game, preserving persistent progress
    });
    document.getElementById('back-to-menu-btn').addEventListener('click', () => { 
        removeGameUIListeners(); // Remove UI listeners
        removeGameUIElementsDisplay(); // Hide UI elements
        clearGameListeners(); // Additional cleanup
        showScreen('start'); 
    });
    // This button (exit-game-btn) was removed, so this listener is effectively gone now.
    // document.getElementById('exit-game-btn').addEventListener('click', () => { 
    //     removeGameUIListeners(); 
    //     removeGameUIElementsDisplay(); 
    //     clearGameListeners(); 
    //     showScreen('start'); 
    // });
    document.getElementById('back-to-menu-from-win-btn').addEventListener('click', () => { 
        removeGameUIListeners(); // Remove UI listeners
        removeGameUIElementsDisplay(); // Hide UI elements
        clearGameListeners(); // Additional cleanup
        stopConfetti(); // Stop confetti animation
        showScreen('start'); 
    });

    // These click listeners are for desktop (or as fallback for touch, though touchstart is preferred)
    // They are attached once DOMContentLoaded, and are always active if buttons are displayed.
    placeBombBtn.addEventListener('click', placeBomb);
    shootDartBtn.addEventListener('click', shootDart);

    notificationCloseBtn.addEventListener('click', hideNotification);

    isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    // Initial display: only start screen, no game UI
    showScreen('start');
});
</script>
</body>
</html>